# 内存机制
- 静态：使用变量前需要知道其类型。
- 动态：在运行过程中需要检查数据类型。
- 弱类型： 支持隐式类型转换
- 强类型：不支持---
- 执行栈维持执行上下文，空间小，保障执行效率
- 开辟堆的问题在于内存分配和垃圾回收的效率

# 垃圾回收
- 手动回收
- 自动回收 
- 栈的垃圾回收是怎样执行的呢
 ESP向下移动会销毁上一个函数在调用栈中的执行上下文。

- 堆中的数据是如何回收的
 https://blog.csdn.net/weixin_47277170/article/details/106141837?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161909715016780264042925%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161909715016780264042925&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-106141837.pc_search_result_no_baidu_js&utm_term=%E4%BB%A3%E9%99%85%E5%81%87%E8%AF%B4

   js垃圾回收器
   1. 代际假说：大部分对象在内存中存在的时间很短，简单来说，很多对象一经分配内存，很快就变的更久；不死的对象会活的久
   v8 会把堆分为 新生代(1-8M) 和 老生代 两个区域。新生代中存放生存时间短的对象，老生代中存放时间长的对象

   - 副垃圾回收器，负责新生代的垃圾回收
   - 主垃圾回收器，负责老生代的垃圾回收

   - 垃圾回收器的工作流程
    1. 标记空间中的活动对象和非活动对象
    2. 回收非活动对象所占据的内存
    3. 整理内存

    副垃圾回收器：
    1. 新生代中分对象区域和空闲区域，死对象放在对象区域，对象区域和空闲ZAXD区域无限循环交换
    <!-- 2. 执行两次垃圾回收后，对象还活着，它被移入老生区(对象晋生策略)ZAXD -->

    主垃圾回收器：
    1.标记-清除（mark-sweep)算法 ，便利对象，标记垃圾数据，清除之。

   2. 分代收集

# js执行机制
1. 实际上变量和函数声名在代码里的位置是不变的，而是在编译阶段被js引擎放入内存中，代码经过编译阶段再到执行阶段
2. 为什么js代码会出现栈溢出?   
- 调用栈是大小的，当入栈的执行上下文超出一定数目，引擎会报错 递归

# 什么是闭包


# 作用域链
 

# 词法作用域 
是指作用域是由代码中函数声明的位置来决定，是静态的，作用域链是由词法作用域来定义的。块级作用域的变量存放在词法环境
/*函数执行访问变量 先找同块级法环境，在找变量环境