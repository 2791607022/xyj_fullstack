# TCP 协议

 - TCP 面向有连接，可靠性。
 - TCP 不只是数据报文的搬运工，保证有序且不丢失的传递
 - TCP 有流量控制,拥塞控制算法，
 - TCP 分包传输

1. 头部
  SYN:同步序列编号。是随机的  SYN 和 ACk 对应的，
  Sequence number:该序号保证传输的报文都是有序的，接收端就可以通过拼接报文 
  Acknowledgement Number:表示应答；它是接收端期望接收的下一个字节的编码(seq)，同时表示上一个序列号的数据已经接收到了
  Window Size ：窗口大小，表示还能接受到多少字节的数据，用于流量控制

服务器只有两次主动向客户端发送请求

# 三次握手 为了建立连接 发生在传输层
 1. 第一次：客服端向服务端发送请求报文，客户端进入SYN-SENT 状态
 2. 第二次：服务端接收到这个请求后，同意则发送应答，服务端进入 SYN-RECEIVED 状态，服务器发送SYN 
 3. 第三次：客户端接收到统一应答后，再向服务端发送一个确认报文，客服端和服务端进入ESTABLISHED状态，此时连接建立成功

 # 为什么TCP 要三次握手，明明两次就可以了 ：避免资源浪费
  两次：客户端发送请求A,应为网络原因A请求超时，TCP就超时重传机制，重新发送连接请求B,服务端收到B后进行应答，数据传递完成释放连接。A在两端关闭后又到达服务器端，服务端响应请求，一直等待，资源浪费。

 # 四次挥手 状态皆为函数。
  1. 客户端认为数据发送完成，向服务端发送释放连接的请求 ，进入 
  2. 服务端接受到释放连接的请求后，告诉应用层该释放TCP连接，然后向客户端发送ACK包进入CLOSE-WAIT状态。此时不再接受客户端的数据了。但是因为TCP双向连接，服务端还能向客户端发送
  3. 如果服务端此时还有没发完的数据就会继续发送，完毕后向客户端发送释放连接请求，这个请求只发一次。自己进入LAST-ACK状态，只接受一个ACK的信号。
  4. 客户端接收到服务端的释放请求，向服务确认应答，自己进入TIME-W状态2ms后进入CLOSED状态。服务端再接收到这个应答也进入CLOSED状态

  # 为什么客户端进入TIME-WAIT状态，等待2ms时间后才进入CLOSED状态
   为了保证服务端能够接受到客服端的确认应答，如果客户端确认应答后进入CLOSED状态，万一网络问题导致应答没有被服务器接受到，那么造成服务端无法关闭。2ms 是数据在网络上的存活时间


  


- 数据传输
客户端向服务端发送requset 请求，服务端返回response;每个包的请求都有seq,ack编号，丢包时，进入超时重传，如果重复接受，只会选择一个包。

挥手时。FIN 断开连接的序列号。


