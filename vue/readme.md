### Vue 生命周期
#### 单组件生命周期
    - 介绍：生命周期是vue在运行期间的各个关键节点运行的钩子函数，以便可以在特定场景做特定的操作。
    - 主要分为4个阶段分别是组件的创建，渲染，更新，销毁。
    - 创建阶段：
        1. beforeCreate， 此时组件实例刚刚创建，组件的属性还未生效，此时组件实例和 state 还未初始化，无法使用this访问当前实例，也无法访问data、props等
        2.created， 此时组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el属性还不可用，不能访问组件dom，此期间一般用来请求接口，做数据初始化操作，但避免请求时间过长，否则会导致出现页面长时间白屏。
    - 渲染阶段：
        1.beforeMount，此时内存中已经编译好了模板，组件实例还没有挂载到DOM 上，相关的 render 函数首次被调用
        2.mounted， 此时组件实例已经挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问
    - 更新阶段：
        1.beforeupdate， 此时组件刚开始进行响应式数据更新，但虚拟DOM打补丁之前，DOM还未重新渲染
        2.updated， 此时虚拟 DOM 已经重新渲染和打完了补丁，组件DOM已经更新，可执行依赖于DOM的操作。避免在这个钩子函数中操作数据，可能陷入死循环
    - 销毁阶段
        1. beforeDestroy， 此时实例还未销毁，实例仍然完全可用，this仍能获取到实例，在这个阶段可以进行销毁定时器、解绑全局事件、销毁插件对象等操作。
        2.destroyed， 此时该实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
#### 父子组件生命周期
    1. 组件初始化时子组件完成挂载后，父组件才会挂载并且主动执行一次beforeUpdate/updated钩子函数，具体执行顺序是 父组件首先依次执行beforeCreate，created 和beforeMount， 然后是子组件执行beforeCreate，created ，beforeMount和mounted，最后再是父组件执行mounted，beforeupdate和updated。
    2. 更新时： 更新分为两种情况，如果只是组件各自的 data更新，那么父子组件的beforeupdate和updated是分别执行的 ；但如果是props的更新，那么首先执行的是
    父组件的beforeUpdate，然后进入子组件的全部更新阶段，最后父组件再更新完成。
    3. 销毁时：如果只是子组件的销毁，那么子组件中会单独执行销毁的两个钩子函数；如果是父组件销毁，那么首先执行父组件的beforeDestroy，然后子组件完成销毁的两个阶段，完全销毁后，父组件再完全销毁。

#### 兄弟组件生命周期
    1.组件的初始化（mounted之前）分开进行，挂载是从上到下依次进行
    2.当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的

### vue组件通信
#### 父子组件通信：
        1.props / $emit方式： 父组件 data 里定义一个属性 a, 这个属性 a 可以作为 props 传递给子组件，子组件中的props属性只需同一个同名的变量接受，即可访问父组件中的这个值，子组件可以听过emit 的方式将 自己的值传给父组件，子组件中可以设置一个函数b,在b中使用vue的$emit 方式将 事件名c和自己的数据传递给父组件，父组件可以在子组件上绑定一个函数d 监听emit中设置事件c，当 子组件事件执行时，父组件就可以在函数中获取到传递过来的值。

        2. $parent和$children 方式：可以通过vue 上的$parent和$children 来访问组件的实例，拿到实例就可以访问此组件的所有方法和data。但这种方式可以会无意中改变实例上的东西，非常不安全，不建议使用
          $children是组件自带的属性，它可以获取到当前组件的子组件，并以数组的形式返回；父组件可以通过this.$children数组获取所以子组件实例，加上下标就可以访问特定子组件上的方法和数据
          如果一个组件是个子组件，它可以通过 this.$parent 访问到父实例，拿到父组件的数据和方法，组件没有父组件，他的$parent为undefined，如果该组件有多个父亲，$parent只能找到一个。

        3.provide/ inject 是vue2.2.0新增的api, 简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。这种方式只能提供单向的数据通信，但它可以忽略组件的嵌套层级，只要调用了inject 那么就可以注入provide中的数据。

        4.ref/refs
            和 parent和children 的原理类似，都是通过访问组件实例来获取数据，当ref作用于组件是，它就可以将组件的引用信息注册到其父组件的refs对象上，父组件通过this.$refs加上 子组件上设置ref名称就可以访问到它。这种方式也只能单向传递，而且不建议使用。当EventBus注册在全局上时，需要在使用$on的组件中在beforeDestroy钩子函数中用$off销毁事件监听，避免重复触发事件。
    
#### 其他关系：
        1.eventBus：事件总线模式在vue中是一种沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通过总线通知其他组件。事件总线实质上是一个功能单一的vue实例。组件A,B组件都引入就它，组件A通过事件总线实例上的$emit 方法传递一个事件名称和自己的数据，事件B通过总线实例上的$on 方法接收一个同名的事件，进而获取到事件上组件A的数据。

        2.Vuex：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储来管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化，它解决了一个状态改变多个组件和多个组件改变一个状态的问题。

        3.localStorage / sessionStorage：可以直接通过浏览器的存储空间作为数据的中转站，任何组件都可以通过getItem 方法获取某个Storage中的数据，并通过setItem去存储或更新某个数据，这种方式简单易用，但数据和状态比较混乱,不太容易维护。

### MVVM
    - 说明：MVVM 作为一种设计模式是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。model中定义数据修改和操作的业务逻辑;view表示ui组件，负责将数据模型转换为ui展现出来，它做的是数据绑定的声明、 指令的声明、 事件绑定的声明。;而viewModel是一个同步view和model的对象。在mvvm框架中，view和model之间没有直接的关系，它们是通过viewModel来进行交互的。mvvm不需要手动操作dom，只需要关注业务逻辑就可以了。

    - 优点：
        1、低耦合性 view和model之间没有直接的关系，通过viewModel来完成数据双向绑定。
        2、可复用性 组件是可以复用的。可以把一些数据逻辑放到一个viewModel中，让很多view来重用。
        3、独立开发 开发人员专注于viewModel，设计人员专注于view。
        4、可测试性 ViewModel的存在可以帮助开发者更好地编写测试代码。
    
    - 实现原理：MVVM实现的核心原理是数据劫持和发布订阅模式
        1.首先 Vue中会先遍历data选项中所有的属性（发布者）用Object.defineProperty劫持这些属性将其转为getter/setter。读取数据时候会触发getter。修改数据时会触发setter。
        2.然后给每个属性对应new Dep()，Dep是专门收集依赖、删除依赖、向依赖发送消息的。先让每个依赖设置在Dep.target上，在Dep中创建一个依赖数组，先判断Dep.target是否已经在依赖中存在，不存在的话添加到依赖数组中完成依赖收集，随后将Dep.target置为上一个依赖。
        3.组件在挂载过程中都会new一个Watcher实例。这个实例就是依赖（订阅者）。Watcher第二参数式一个函数，此函数作用是更新且渲染节点。在首次渲染过程，会自动调用Dep方法来收集依赖，收集完成后组件中每个数据都绑定上该依赖。当数据变化时就会在seeter中通知对应的依赖进行更新。在更新过程中要先读取数据，就会触发Wacther的第二个函数参数。一触发就再次再次自动调用Dep方法收集依赖，同时在此函数中运行patch（diff运算)来更新对应的DOM节点，完成了双向绑定。

### SPA单页面

### Vuex
    - 五个核心概念:state、getters、mutations、actions、modules。
        - state 是 store 中数据的唯一状态，
        - getters 则是用于在数据的原生状态上获取派生状态的方法，
        - mutations 是用于同步更改状态的唯一方案，在store中定义某个 mutation 用来改变state时，外部需要使用store的commit方法提交一个mutation的type来触发对应的 mutation 处理器，进行数据的更新；
        - action可以为我们提供异步修改 state的功能。每个action都可以获取到当前store实例的方法和属性，在action中可以进行异步操作，在最终更新state时可以直接赋值或commit一个 mutation，外部使用这个action 方法需要使用store的dispatch 方法 提交这个action的type来触发对应的 action 处理器
        - Module 用于store模块化，Vuex 允许我们将 store 分割成模块。每个模块拥有自己的 state、mutation，最后将多个状态树再组合成完整的状态树

    - 相关辅助函数：
        - mapState支持在组件中批量使用Vuex的state状态
        - mapGetters 支持组件中批量使用Vuex的getter属性和重命名
        - mapMutations方便组件中多次提交同一个mutation
        - mapActions 方便组件中多次提交同一个action

### v-model
    1.介绍：v-model 是 Vue 框架提供的众多指令中的一个，其主要作用是实现在表单 <input>、<textarea> 及 <select> 标签元素上创建双向数据绑定。
    2.v-model 在本质上是一种v-bind 和v-on 结合的语法糖，对于input标签来说，使用 v-model绑定一个值，相当于使用 v-bind 绑定value属性的值, 使用v-on绑定标签上的input事件监听到函数中，函数会获取最新的值并赋值到绑定的属性中。它会根据不同的标签分别绑定不同属性值并监听属性值改变对应的原生事件。双向绑定核心涉及到的是vue 响应式原理

### v-show 和 v-if 的异同
    v-if和v-show是用来控制元素显示和隐藏的两个指令。它们在视觉效果上看起来类似，但在使用时有一些重要的区别。
    1 v-if和v-show的实现方式不同
        v-if是一种条件渲染指令，它会根据表达式的值来插入或删除元素。当表达式的值为真时，元素会被插入到DOM中，否则会从DOM中删除。
        v-show是一种简单的显示/隐藏指令，它会根据表达式的值来显示或隐藏元素。当表达式的值为真时，元素会被显示，否则会被隐藏。
    2 v-if和v-show的性能不同
        由于v-if的工作原理是从DOM中添加或删除元素，因此它对于频繁切换的元素具有较高的开销。每次切换时，v-if都需要重新渲染元素及其所有子元素。
        v-show则不会从DOM中删除元素，而是使用CSS的display属性来控制元素的显示或隐藏。因此，v-show对于频繁切换的元素具有更好的性能，因为元素的渲染不需要重复进行。
    3 v-if和v-show的适用场景不同
        v-if适用于只有在满足特定条件时才需要渲染的元素，因为它可以节省不必要的DOM元素和子元素的渲染开销。
        v-show适用于需要在不同的状态之间切换的元素，因为它可以避免在切换时重新渲染元素及其所有子元素。

### watch和computed的异同
    两者都是用于观察页面数据变化的方法。
    - computed：它是计算属性，会根据所依赖的数据进行同步操作来获得新的计算结果, 该计算结果会被缓存起来。computed的值在执行后是会被缓存的。如果所依赖的数据发生改变时候, 就会重新调用计算来获取最新的结果，同时它会在页面第一次加载时立即执行一次，它适合于在一个属性受多个属性影响的时候使用，可以获取该属性最新的值，

    - watch 可以对data里的数据监听，当依赖的data的数据变化时, 会执行回调设置的回调函数，回调函数中有newVal和oldVal两个参数可以获取到新旧两个状态，在回调函数中可以执行自定义的操作，watch 不会在第一次加载时执行，在回调外部需要设置属性 immediate 为 true, 它才会立即执行；另外还有一个属性为 deep,当设置为 true 时，watch能对监听的数据进行深度监听，适合引用类型的数据；watch 适合某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时


### keep-alive

### nextTrick

### vue-slot 

### css scoped

### v-for相关

### Vue3 新特性

[相关面试题]：https://juejin.cn/post/6844903934306287629