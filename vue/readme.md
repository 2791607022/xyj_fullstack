### Vue 生命周期
#### 单组件生命周期
    - 介绍：生命周期是vue在运行期间的各个关键节点运行的钩子函数，以便可以在特定场景做特定的操作。
    - 主要分为4个阶段分别是组件的创建，渲染，更新，销毁。
    - 创建阶段：
        1. beforeCreate， 此时组件实例刚刚创建，组件的属性还未生效，此时组件实例和 state 还未初始化，无法使用this访问当前实例，也无法访问data、props等
        2.created， 此时组件实例已经完全创建，属性也绑定在实例上，但真实dom还没有生成，$el属性还不可用，不能访问组件dom，此期间一般用来请求接口，做数据初始化操作，但需要避免请求时间过长，否则会导致出现页面长时间白屏。
    - 渲染阶段：
        1.beforeMount，此时内存中已经编译好了模板，组件实例还没有挂载到DOM 上，相关的 render 函数首次被调用
        2.mounted， 此时组件实例已经挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问
    - 更新阶段：
        1.beforeupdate， 此时组件刚开始进行响应式数据更新，但虚拟DOM打补丁之前，DOM还未重新渲染
        2.updated， 此时虚拟 DOM 已经重新渲染和打完了补丁，组件DOM已经更新，可执行依赖于DOM的操作。避免在这个钩子函数中操作数据，可能陷入死循环
    - 销毁阶段
        1. beforeDestroy， 此时实例还未销毁，实例仍然完全可用，this仍能获取到实例，在这个阶段可以进行销毁定时器、解绑全局事件、销毁插件对象等操作。
        2.destroyed， 此时该实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
#### 父子组件生命周期
    1. 组件初始化时子组件完成挂载后，父组件才会挂载并且主动执行一次beforeUpdate/updated钩子函数，具体执行顺序是 父组件首先依次执行beforeCreate，created 和beforeMount， 然后是子组件执行beforeCreate，created ，beforeMount和mounted，最后再是父组件执行mounted，beforeupdate和updated。
    2. 更新时： 更新分为两种情况，如果只是组件各自的 data更新，那么父子组件的beforeupdate和updated是分别执行的 ；但如果是props的更新，那么首先执行的是父组件的beforeUpdate，然后进入子组件的全部更新阶段，最后父组件再更新完成。
    3. 销毁时：如果只是子组件的销毁，那么子组件中会单独执行销毁的两个钩子函数；如果是父组件销毁，那么首先执行父组件的beforeDestroy，然后子组件完成销毁的两个阶段，完全销毁后，父组件再完全销毁。

#### 兄弟组件生命周期
    1.组件的初始化（mounted之前）分开进行，挂载是从上到下依次进行
    2.当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的

### vue组件通信
#### 父子组件通信：
        1.props / $emit方式： 父组件 data 里定义一个属性 a, 这个属性 a 可以作为 props 传递给子组件，子组件中的props属性只需同一个同名的变量接受，即可访问父组件中的这个值，子组件可以听过emit 的方式将 自己的值传给父组件，子组件中可以设置一个函数b,在b中使用vue的$emit 方式将 事件名c和自己的数据传递给父组件，父组件可以在子组件上绑定一个函数d 监听emit中设置事件c，当 子组件事件执行时，父组件就可以在函数中获取到传递过来的值。

        2. $parent和$children 方式：可以通过vue 上的$parent和$children 来访问组件的实例，拿到实例就可以访问此组件的所有方法和data。但这种方式可以会无意中改变实例上的东西，非常不安全，不建议使用
          $children是组件自带的属性，它可以获取到当前组件的子组件，并以数组的形式返回；父组件可以通过this.$children数组获取所以子组件实例，加上下标就可以访问特定子组件上的方法和数据
          如果一个组件是个子组件，它可以通过 this.$parent 访问到父实例，拿到父组件的数据和方法，组件没有父组件，他的$parent为undefined，如果该组件有多个父亲，$parent只能找到一个。

        3.provide/ inject 是vue2.2.0新增的api, 简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。这种方式只能提供单向的数据通信，但它可以忽略组件的嵌套层级，只要调用了inject 那么就可以注入provide中的数据。

        4.ref/refs
            和 parent和children 的原理类似，都是通过访问组件实例来获取数据，当ref作用于组件是，它就可以将组件的引用信息注册到其父组件的refs对象上，父组件通过this.$refs加上 子组件上设置ref名称就可以访问到它。这种方式也只能单向传递，而且不建议使用。当EventBus注册在全局上时，需要在使用$on的组件中在beforeDestroy钩子函数中用$off销毁事件监听，避免重复触发事件。
    
#### 其他关系：
        1.eventBus：事件总线模式在vue中是一种沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通过总线通知其他组件。事件总线实质上是一个功能单一的vue实例。组件A,B组件都引入就它，组件A通过事件总线实例上的$emit 方法传递一个事件名称和自己的数据，事件B通过总线实例上的$on 方法接收一个同名的事件，进而获取到事件上组件A的数据。

        2.Vuex：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储来管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化，它解决了一个状态改变多个组件和多个组件改变一个状态的问题。

        3.localStorage / sessionStorage：可以直接通过浏览器的存储空间作为数据的中转站，任何组件都可以通过getItem 方法获取某个Storage中的数据，并通过setItem去存储或更新某个数据，这种方式简单易用，但数据和状态比较混乱,不太容易维护。

### MVVM
    - 说明：MVVM 作为一种设计模式是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。model中定义数据修改和操作的业务逻辑;view表示ui组件，负责将数据模型转换为ui展现出来，它做的是数据绑定的声明、 指令的声明、 事件绑定的声明。;而viewModel是一个同步view和model的对象。在mvvm框架中，view和model之间没有直接的关系，它们是通过viewModel来进行交互的。mvvm不需要手动操作dom，只需要关注业务逻辑就可以了。

    - 优点：
        1、低耦合性 view和model之间没有直接的关系，通过viewModel来完成数据双向绑定。
        2、可复用性 组件是可以复用的。可以把一些数据逻辑放到一个viewModel中，让很多view来重用。
        3、独立开发 开发人员专注于viewModel，设计人员专注于view。
        4、可测试性 ViewModel的存在可以帮助开发者更好地编写测试代码。
    
    - 实现原理：MVVM实现的核心原理是数据劫持和发布订阅模式
        1.首先 Vue中会先遍历data选项中所有的属性（发布者）用Object.defineProperty劫持这些属性将其转为getter/setter。读取数据时候会触发getter。修改数据时会触发setter。
        2.然后给每个属性对应new Dep()，Dep是专门收集依赖、删除依赖、向依赖发送消息的。先让每个依赖设置在Dep.target上，在Dep中创建一个依赖数组，先判断Dep.target是否已经在依赖中存在，不存在的话添加到依赖数组中完成依赖收集，随后将Dep.target置为上一个依赖。
        3.组件在挂载过程中都会new一个Watcher实例。这个实例就是依赖（订阅者）。Watcher第二参数式一个函数，此函数作用是更新且渲染节点。在首次渲染过程，会自动调用Dep方法来收集依赖，收集完成后组件中每个数据都绑定上该依赖。当数据变化时就会在seeter中通知对应的依赖进行更新。在更新过程中要先读取数据，就会触发Wacther的第二个函数参数。一触发就再次再次自动调用Dep方法收集依赖，同时在此函数中运行patch（diff运算)来更新对应的DOM节点，完成了双向绑定。

### SPA单页面
    - 介绍：SPA是一种只需要将单个页面加载到服务器之中的web应用程序。当浏览器向服务器发出第一个请求时，服务器会返回一个index.html文件，它所需的js，css等会在显示时统一加载，部分页面按需加载。url地址变化时不会向服务器在请求新的页面，通过路由实现页面切换。
    - 优点：
        1.良好的交互体验，用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅；
        2.良好的前后端工作分离模式。
    - 缺点：
        1.不利于搜索引擎的抓取，由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。
        2.首屏加载过慢（初次加载耗时多）
    
    - SPA路由切换方式：
        1.hash 模式：它是一种把前端路由的路径用井号 # 拼接在真实 URL 后面的模式。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 hashchange 的监听事件，在hashchange的监听事件内可以得到改变后的url，这样能够找到对应页面进行加载。
        2. history模式： history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求。history中有一些重要的方法，back方法会在浏览器的历史记录向后移一位，forward方法则是向前一页， go 方法是加载特定的一页，pushState可以当前浏览器历史中添加记录，而replaceState方法可以将当前页面替换为目标页面。SPA中可以通过pushState 、 replaceState 方法来实现无刷新跳转的功能。
        3. 区别：hash 路由兼容梗好，但是带#显得丑些；histroy模式下的url和正常 url 路径一样，但兼容性比 hash模式低，而且需要服务端的配合，因为浏览器在刷新的时候，应用会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，服务端可能不存在这个资源，导致返回 404 。

    - SPA首屏加载优化(放入优化篇)

### Vuex
    - 五个核心概念:state、getters、mutations、actions、modules。
        - state 是 store 中数据的唯一状态，
        - getters 则是用于在数据的原生状态上获取派生状态的方法，
        - mutations 是用于同步更改状态的唯一方案，在store中定义某个 mutation 用来改变state时，外部需要使用store的commit方法提交一个mutation的type来触发对应的 mutation 处理器，进行数据的更新；
        - action可以为我们提供异步修改 state的功能。每个action都可以获取到当前store实例的方法和属性，在action中可以进行异步操作，在最终更新state时可以直接赋值或commit一个 mutation，外部使用这个action 方法需要使用store的dispatch 方法 提交这个action的type来触发对应的 action 处理器
        - Module 用于store模块化，Vuex 允许我们将 store 分割成模块。每个模块拥有自己的 state、mutation，最后将多个状态树再组合成完整的状态树

    - 相关辅助函数：
        - mapState支持在组件中批量使用Vuex的state状态
        - mapGetters 支持组件中批量使用Vuex的getter属性和重命名
        - mapMutations 用于在组件中映射mutation内的方法，以便在组件中直接使用
        - mapActions  用于在组件中映射action内的方法，以便在组件中直接使用

### v-model
    1.介绍：v-model 是 Vue 框架提供的众多指令中的一个，其主要作用是实现在表单 <input>、<textarea> 及 <select> 标签元素上创建双向数据绑定。
    2.v-model 在本质上是一种v-bind 和v-on 结合的语法糖，对于input标签来说，使用 v-model绑定一个值，相当于使用 v-bind 绑定value属性的值, 使用v-on绑定标签上的input事件监听到函数中，函数会获取最新的值并赋值到绑定的属性中。它会根据不同的标签分别绑定不同属性值并监听属性值改变对应的原生事件。双向绑定核心涉及到的是vue 响应式原理

### v-show 和 v-if 的异同
    v-if和v-show是用来控制元素显示和隐藏的两个指令。它们在视觉效果上看起来类似，但在使用时有一些重要的区别。
    1 v-if和v-show的实现方式不同
        v-if是一种条件渲染指令，它会根据表达式的值来插入或删除元素。当表达式的值为真时，元素会被插入到DOM中，否则会从DOM中删除。
        v-show是一种简单的显示/隐藏指令，它会根据表达式的值来显示或隐藏元素。当表达式的值为真时，元素会被显示，否则会被隐藏。
    2 v-if和v-show的性能不同
        由于v-if的工作原理是从DOM中添加或删除元素，因此它对于频繁切换的元素具有较高的开销。每次切换时，v-if都需要重新渲染元素及其所有子元素。
        v-show则不会从DOM中删除元素，而是使用CSS的display属性来控制元素的显示或隐藏。因此，v-show对于频繁切换的元素具有更好的性能，因为元素的渲染不需要重复进行。
    3 v-if和v-show的适用场景不同
        v-if适用于只有在满足特定条件时才需要渲染的元素，因为它可以节省不必要的DOM元素和子元素的渲染开销。
        v-show适用于需要在不同的状态之间切换的元素，因为它可以避免在切换时重新渲染元素及其所有子元素。

### watch和computed的异同
    两者都是用于观察页面数据变化的方法。
    - computed：它是计算属性，会根据所依赖的数据进行同步操作来获得新的计算结果, 该计算结果会被缓存起来。computed的值在执行后是会被缓存的。如果所依赖的数据发生改变时候, 就会重新调用计算来获取最新的结果，同时它会在页面第一次加载时立即执行一次，它适合于在一个属性受多个属性影响的时候使用，可以获取该属性最新的值，

    - watch 可以对data里的数据监听，当依赖的data的数据变化时, 会执行回调设置的回调函数，回调函数中有newVal和oldVal两个参数可以获取到新旧两个状态，在回调函数中可以执行自定义的操作，watch 不会在第一次加载时执行，在回调外部需要设置属性 immediate 为 true, 它才会立即执行；另外还有一个属性为 deep,当设置为 true 时，watch能对监听的数据进行深度监听，适合引用类型的数据；watch 适合某个数据发生变化时, 我们需要做一些操作, 或者当需要在数据变化时执行异步或开销较大的操作时

### keep-alive
    - 介绍：
        在平常开发中，有部分组件没有必要多次初始化，这时，我们需要将组件进行持久化，使组件的状态维持不变，在下一次展示时，也不会进行重新初始化组件，而keep-alive可以使被包含的组件保留状态，或避免重新渲染 。也就是所谓的组件缓存。
    - 属性：
       1.include 设定的值可以为字符串，数组，以及正则表达式,只有匹配到名称的组件会被缓存
       2.exclude 中匹配到的组件不会被缓存，它的优先级高于include。
       3.max 设定的则是缓存组件的最大值。
    - 新的生命周期函数：
        缓存了组件之后，再次进入组件不会触发beforeCreate、created 、beforeMount、 mounted，同样的离开缓存组件的时候，组件的beforeDestroy和destroyed也不会触发，
        所以缓存组件会有新的两个生命周期函数
        1. activated 当 keep-alive 包含的组件再次渲染的时候触发
        2. deactivated 当 keep-alive 包含的组件销毁的时候触发
    - 原理：
        keep-alive实现核心是LRU(Least Recently Used)算法，主要分为四个步骤
            1.获取 keep-alive 包裹着的第一个子组件对象及其组件名； 如果 keep-alive 存在多个子元素，keep-alive 要求同时只有一个子元素被渲染。所以在开头会获取插槽内的子元素，调用 getFirstComponentChild 获取到第一个子元素的 VNode。
            2.根据设定的黑白名单（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例（VNode），否则开启缓存策略。
            3.根据组件ID和tag生成缓存Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该key在this.keys中的位置（更新key的位置是实现LRU置换策略的关键）。
            4.如果不存在，则在this.cache对象中存储该组件实例并保存key值，之后检查缓存的实例数量是否超过max设置值，超过则根据LRU置换策略删除最近最久未使用的实例（即是下标为0的那个key）。最后将该组件实例的keepAlive属性值设置为true。


### nextTick
    1. 介绍：Vue的响应式并不是指数据发生变化之后，DOM就立刻发生变化，而是按照一定的策略进行DOM的更新，当有数据更新时，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变，如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要，当下一个事件循环开始时，Vue 会刷新该缓冲队列并执行DOM更新。有时我们需要在数据更新后立即获取到相关DOM的最新状态，但这个操作是一个同步操作，会在本次事件循环中执行，我们拿到的DOM还是更新之前的DOM，nextTick函数就可以帮助我们解决该问题，nextTick中的回调函数会被延迟到下次DOM更新的后面，这样我们就可以获取最新的DOM。

### vue-slot 
    1.介绍：Slot 通俗的理解就是“占坑”，在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中slot位置），并且可以作为承载分发内容的出口。
    2.使用:
        slot 内部可以包涵普通文本，模版代码，甚至是其他组件;
        插槽跟模板其他地方一样都可以访问相同的实例属性，即父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的；
        当我们一个组件里需要多个插槽时，可以使用<slot>元素的name属性来定义额外的插槽;

### css scoped
    1.背景：Vue 项目在组件里写 css 的时候，经常会给 <style> 标签加上 scoped ，这样写出来的 css 就是局部的，不会影响其他组件。
    2. 事项原理：vue中的scoped属性的效果主要通过PostCSS转译实现，通过观察渲染的DOM结构可以发现，在DOM结构以及css样式上加了唯一的标记，使样式唯一且只作用于含有该属性的dom——组件内部dom
    3.问题：如果组件内部还有组件，那只会给最外层组件加唯一属性字段，不影响组件内部子组件的样式，会导致父组件无法直接修改子组件的样式，这时我们可以进行进行样式穿透，在 sass和less中可以使用 /deep/ 处理，在  stylus中可以使用 >>> 来处理。

### v-for相关
    - v-for和v-if：
        v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染，v-for 指令基于一个数组来渲染一个列表
        当两者处于同一节点上，因为v-for的优先级比v-if更高，v-if 将分别重复运行于每个 v-for 循环中。
        如果需要渲染数组中满足某个条件的项时，可以在同一节点上使用v-for和v-if,
        如果需要某个条件渲染一整个数组时，需要在外部先使用v-if判断，然后再使用v-for 循环。
    - v-for 添加 key 的作用

        当渲染的是一个简单的列表，它不依赖子组件状态或临时DOM状态，比如表单输入值的列表渲染输出,不用key性能会更好，因为不用key采用的是“就地更新”的策略。如果数据项的顺序被改变， Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，这时如果加上了key会导致节点位置进行交换，但是内容没有更新

        当渲染的是一个复杂的组件列表时，vue用diff算法来对比新旧虚拟节点来更新节点，在diff算法中，旧节点会生成一个健为key，值为节点下标index的map映射，如果新节点有key，会通过map映射找到对应的旧节点，如果新节点没有key，会采用遍历查找的方式去找到对应的旧节点，、map映射比遍历查找效率更高
    
    - key 的其他作用和注意事项
        - 它可以完整地触发组件的生命周期钩子，使DOM标签能够随着内容改变进行更新，触发过渡效果。
        - 不要使用对象或数组之类的非基本类型值作为key，请用字符串或数值类型的值；不要使用数组的index作为key值，因为在删除数组某一项，index也会随之变化，导致key变化，渲染会出错。


### vue-router

### Vue3 
    [https://juejin.cn/post/7227453567686033468#heading-3]
    [https://juejin.cn/post/6940454764421316644?searchId=2023081118431061483CF4627BD00F414E#heading-29]
    [https://juejin.cn/post/7139921537896808479?searchId=20230811202456BA5CB451332006251808]
#### vue3的更新
    1.性能优化：Vue.js 3.0使用了Proxy替代Object.defineProperty实现响应式，并且使用了静态提升技术来提高渲染性能。新增了编译时优化，在编译时进行模板静态分析，并生成更高效的渲染函数。

    2.Composition API：Composition API是一个全新的组件逻辑复用方式，可以更好地组合和复用组件的逻辑。
    
    3.TypeScript支持：Vue.js 3.0完全支持TypeScript，在编写Vue应用程序时可以更方便地利用TS的类型检查和自动补全功能。
    
    4.新的自定义渲染API：Vue.js 3.0的自定义渲染API允许开发者在细粒度上控制组件渲染行为，包括自定义渲染器、组件事件和生命周期等。

    5.改进的Vue CLI：Vue.js 3.0使用了改进的Vue CLI，可以更加灵活地配置项目，同时支持Vue.js2.x项目升级到Vue.js 3.0。

##### Proxy和Object.defineProperty的区别
    Proxy和Object.defineProperty都可以用来实现JavaScript对象的响应式，但是它们有一些区别：
    1.实现方式：Proxy是ES6新增的一种特性，使用了一种代理机制来实现响应式。而Object.defineProperty是在ES5中引入的，使用了getter和setter方法来实现。

    2.作用对象：Proxy可以代理整个对象，包括对象的所有属性、数组的所有元素以及类似数组对象的所有元素。而Object.defineProperty只能代理对象上定义的属性。

    3.监听范围：Proxy可以监听到新增属性和删除属性的操作，而Object.defineProperty只能监听到已经定义的属性的变化。

    4.性能：由于Proxy是ES6新增特性，其内部实现采用了更加高效的算法，相对于Object.defineProperty来说在性能方面有一定的优势。

#### Vue3的性能优化
    主要包括四个方面
    1.响应式系统优化：Vue3引入了新的响应式系统，这个系统的设计让Vue3的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟DOM。这个新系统的一个重要改进就是提供了一种基于Proxy实现的响应式机制，这种机制为开发人员提供更加高效的API，也减少了一些运行时代码。

    2.编译优化：Vue3的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了Tree shanking的懒加载优化，减少了包的体积。
    
    3.更快的虚拟DOM：Vue3对虚拟DOM进行了优化，使用了跟React类似的Fiber算法，这样可以更加高效地更新DOM节点，提高性能。
    
    4.Composition API：Vue3引入了Composition API，这种API通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。这种API不仅可以让Vue3应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化

#### Vue3的响应式原理
    vue3响应式使用ES6的Proxy和Reflect API来实现，Reflect API可以更加方便地实现对对象的监听和更新，可以用来访问、检查和修改对象的属性和方法。
    Vue3会将响应式对象转换为一个Proxy对象，并利用Proxy对象的get和set拦截器来实现对属性的监听和更新。当访问响应式对象的属性时，get拦截器会被触发，此时会收集当前的依赖关系，并返回属性的值；当修改响应式对象的属性时，set拦截器会被触发，此时会触发更新操作，并通知相关的依赖进行更新。
    解决了Vue2中一些数组操作和对象中新增，删除属性导致的bug。

#### Vue3生命周期变化
    vue3去除了beforecate和created两个生命周期函数，它们直接被setup函树替代，剩下的生命周期函数都可以在 setup里使用，作用和执行的顺序和vue2一致。
#### Composition API 和 Options API 的区别
    1.Options API是Vue早期版本中使用的编写方式，通过定义一个options对象进行组件的配置，包括props、data、methods、computed、watch等选项。这种方式的优点在于结构清晰、易于理解，在小型项目中比较实用。

    2.Composition API是Vue3版本中新引入的一种组件编写方式，它以函数的形式组织我们的代码，允许我们将相关部分组合起来，提高了代码的可维护性和重用性。Composition API还提供了模块化、类型推断等功能，可以更好地实现面向对象编程的思想。Composition API 更好的代码组织，更好的逻辑服用；可维护性，更好的类型推导，可拓展性更好；适用于大型项目

#### setup函数
    - 介绍：setup是组件内使用 Composition API的入口，它接受两个参数：props: 组件传入的属性，context是一个包含了一些实用的对象和方法的上下文对象。setup需要返回一个对象，这个对象包含了组件中需要使用的所有数据和方法等。
    - 优点：在vue2中我们对一个状态进行可能会涉及到 data、methods、computed 等多个部分的操作，但业务比较复杂时，代码可读性和可维护性非常糟糕，使用 steup可以把数据的定义和操作集合在一起，按照逻辑分割成代码块，这样极大地提升了代码可读性和可维护性，这样的拆分还能提升代码的组件化，提高逻辑的复用性。
    - 获取组件实例：可以使用getCurrentInstance() 方法来获取组件实例。getCurrentInstance() 方法返回一个对象，该对象包含了组件实例以及其他相关信息

#### 响应式API
    - ref 和 reative: ref 和 reative 都可以将数据变为响应式数据，当数据发生更改时，vue3会重新构建或重新运行依赖于它们的所有内容。
    ref() 与 reactive() 主要有三个区别
        1.ref 可以接受原始类型以及对象作为参数，但reative 接受对象，
        2. 对于对象类型，使用ref进行处理时，需要通过.value属性才能访问到对象中的属性值，而reactive可以直接访问。
        3. 使用 ref() 函数可以替换整个对象实例，改变整个对象的引用地址，但是reactive() 函数不行
    创建ref对象时会对判断参数是不是 object，如果是的话，变成 reactive 的形式，把 object 变成 reactive ，即利用 reactive 来实现引用类型的响应性，然后在挂到 value 上面,所以我们才必须使用value访问属性的对象

    - toRef 和 toRefs: 通过 reactive 和 ref进行响应式处理过的对象，如果我们从中解构了一些属性并赋值给一些新变量，那么变量会失去和原对象的响应式，变量的修改不会同步到对应的属性上，如果想要解构后的属性保证响应式，可以使用toRef 和 toRefs。
        toRef 接受一个响应式对象和一个属性名称，将该属性单独进行响应时操作；
        toRefs函数接受响应式对象，它会将将响应式对象中的所有属性转换为单独的响应式数据，对象成为普通对象，并且值是关联的。

#### Teleport
    - 介绍：Teleport可以使一个组件传送到任意的地方；我们实际开发中经常会在子组件Header中使用到Dialog组件，此时Dialog就被渲染到一层层子组件内部，处理嵌套组件的定位、z-index和样式都变得困难，我们希望续在组件内部使用Dialog, 又希望渲染的 DOM 结构不嵌套在组件的 DOM 中，这时我们可以使用Teleport组件
    - 使用：Teleport中的属性 to 可以指定组件需要挂载到的 DOM 节点的 ID，如果使用插槽的方式定义了目标容器也可以传入一个选择器字符串，也可以绑定一个 Vue 组件实例
    它可以方便地实现一些弹出框、提示框等组件的功能，提高了开发效率。

#### watch和watchEffect的区别
    1.watch 既要指明监视的数据源，也要指明监视的回调。而 watchEffect 可以自动监听数据源作为依赖。不用指明监视哪个数据，监视的回调中用到哪个数据，那就监视哪个数据。
    2.watch 可以访问改变之前和之后的值，watchEffect 只能获取改变后的值。
    3. watch 如果不设置immediate为true,那么运行的时候不会立即执行，值改变后才会执行，而 watchEffect 运行后可立即执行。
    
#### script setup
    scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好.它的特点包括：
    1.属性和方法无需返回，可以直接使用。
    2.引入组件的时候，会自动注册，无需通过 components 手动注册。  
    3.使用 defineProps 接收父组件传递的值。
    4.使用 useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。
#### vue2和vue3 核心 diff 算法区别
    - Vue 2使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。
    - Vue 3使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。

[相关面试题]：https://juejin.cn/post/6844903934306287629