[https://juejin.cn/post/7028478428680552456?searchId=20230812142011C77AF735F6D86C9D0FDB]
[https://juejin.cn/post/7176644710847479869?searchId=202308121414485195F2B81FDEFB9E9997]

### JS基础

#### 数据类型
    - 基础类型：：Number、String、Boolean、Null、Undefined、Symbol、BigInt
    - 引用类型：Object、Function、Array、RegExp、Date 基本包装类型及单体内置对象(Global、Math)等
    - 区别：基本数据类型的值保存在栈里面，可以直接访问；引用数据类型保存在堆里面，栈里面保存的是地址，通过栈里面的地址去访问堆里面的值
    - null 和 undefined 的区别：null表示一个对象被定义了，值为“空值”,undefined表示不存在这个值。就是此处应该有一个值，但是还没有定义

#### 数据类型判断方法
    - typeof: typeof可以区分除了Null类型以外的其他基本数据类型，以及从对象类型中识别出函数，但不能识别数组; typeof null返回的是 "object"，原因在底层的js系统中，会通数据的二进制形式的前三位 来判断当前数据的类型是哪一种，如果是 000 会判断为对象，因为 null 在 JS 的最初设计的表现形式的前三位也是 000，所以造成了误判。

    - instanceof： 用来判断引用数据的具体类型，它会将左边实例的隐式原型和右边构造函数的显示原型进行循环比对。看看是否有哪一级能对上，有对的上的就返回true,一直顺着原型链找到头都没有比对成功的，返回false；所以它可以正确判断出引用类型的数据具体属于 Array,Function和Object中的哪一种。

    - Object.prototype.toString.call：这种判断方法是几种方法中判断类型最完善，结果最为准确的方法。
        原理：
            如果调用方法的this的值是undefined，返回"[object Undefined]"。
            如果调用方法的this的值是null，返回"[object Null]"。
            如果是其他值，则先将this的值作为参数传给 ToObject 函数调用并得到结果
            将结果的[[Class]]属性值作为变量class进行拼接，最终的结果是"[object class]"。

            如果this的值是String、Number、Boolean等原始类型，则先把原始类型准换成对应的引用类型，然后获取其引用类型的[[Class]]属性值，即 "String" 、 "Number" 、 "Boolean" 等字符串，然后拼接为"[object String]"、"[object Number]"、"[object Boolean]"。
            如果this的值是Math、Date、RegExp、Error、Function、Array、JSON、Object、Arguments等引用类型，则直接获取其[[Class]]属性值。

            call 方法修改了toString 方法的this指向，将指向从Object改为括号内的值

    - Array.isArray：Array 原型上的方法，用于判断数据是否为数组

#### 类型转换
    - == 和 === 的区别： 双等号只会对两边的值进行判断，遇到不同类型的值会进行隐式类型转换，再进行值的比较；三等号不仅会对比值，也会对比值的类型。

### JS 进阶

#### 作用域和作用域链
    -介绍：
        作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。作用域决定了代码区块中变量和其他资源的可见性。一般可分为：全局作用域、局部作用域（函数作用域）、块级作用域。

    - 分类：
        全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。

        局部作用域：也叫做函数作用域，如果一个变量是在函数内部声明的，它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。
        块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫做块级作用域。

    - 作用域链：
        当在 JS 中使用一个变量时，JS 引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推，直至找到该变量或是查找至全局作用域，如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。


#### 闭包
    - 介绍：在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，它是函数与其词法环境的引用，闭包可以使内部函数访问到外部函数的作用域；当从函数内部返回一个内部函数时，返回的函数将会保留当前闭包，即外层函数的词法环境

    - 原理：一般函数中的变量是存储在栈内存，一般在它的当前执行环境结束就会被销毁和回收；
    而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 
    堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。闭包实际上是一个引用，其的中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量

    - 作用：
        保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
        保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化
    - 问题:
        变量都被保存在内存中，内存消耗很大,容易产生内存泄漏
        会在父函数外部，改变父函数内部变量的值

#### this
    概念：
        this是 JS 的一个关键字，它是函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，this的值会发生变化，但有一个总的原则：this指的是调用函数的那个对象。
    this的指向：
        ① 作为普通函数执行时，this指向window，但在严格模式下this指向undefined。
        ② 函数作为对象里的方法被调用时，this指向该对象.
        ③ 当用new运算符调用构造函数时，this指向返回的这个对象。
        ④ 箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象。如果存在嵌套，则this绑定到最近的一层对象上。

#### new 的机制
    首先创建了一个新的空对象
    设置原型，将对象的原型设置为函数的prototype对象。
    让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性）
    判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

#### 继承的实现方式


#### 原型和原型链
    

#### call、apply、bind
    - call:该函数传递两个参数，第一个参数是指定函数内部中this的指向，第二个参数是函数调用时需要传递的参数。call改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次。
    - apply：该函数接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入。改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次。
    - bind：该函数的第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)。bind 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数，需要手动调用。

#### 数组方法
    - 

#### for in / for of

#### 深浅拷贝
    - 浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址。常用的方法有：object.assign，扩展运算符
    - 深拷贝：

#### 防抖/节流
    - 防抖：多次触发事件，事件处理函数只执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发，准备执行事件函数前，会等待一定的时间，在这个等待时间内，如果没有再次被触发，那么就执行，如果又触发了，那就本次作废，重置等待时间，直到最终能执行。

    - 节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。

    - 应用场景：防抖适用于搜索框搜索输入，用户最后一次输入完，再发送请求；手机号、邮箱验证输入检测，
    节流适用于 高频点击、表单重复提交等场景。

#### event loop 事件循环

#### JS内存泄漏
    - 介绍：内存泄漏一般是指系统进程不再用到的内存，没有及时释放，造成内存资源浪费，导致程序运行速度减慢甚至系统崩溃等严重后果
    - 可能原因：
        1.全局变量：在局部作用域中，函数执行完毕后，变量就没有存在的必要了，垃圾回收机制很快的做出判断并回收；但是对于全局变量，很难判断什么时候不用这些变量，无法正常回收。
        解决办法：
            ① 尽量少使用全局变量；
            ② 使用严格模式，在 js 文件头部或者函数的顶部加上use strict。

        2.闭包引起的内存泄露：闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中，如果在使用结束后没有将局部变量清除，就可能导致内存泄露。
        解决办法：将事件处理函数定义在外部，解除闭包。

        3.被遗忘的定时器：定时器setInterval或者setTimeout不再需要使用时，且没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，就会造成内存泄漏。
        解决办法：当不需要定时器的时候，调用clearInterval或者clearTimeout手动清除。

        4.没有及时清除的事件监听：垃圾回收机制不好判断事件是否需要被解除，导致callback不能被释放，此时需要手动解除绑定。
        解决办法：及时使用removeEventListener移除事件监听。

#### JS垃圾回收机制

### ES6/7 新特性

#### 箭头函数

#### let const var 
    
####  map 和 set

#### weakMap 和 weakSet

#### promise

#### async/await