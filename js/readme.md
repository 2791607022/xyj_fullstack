试题：[https://juejin.cn/post/7028478428680552456?searchId=20230812142011C77AF735F6D86C9D0FDB]
试题：[https://juejin.cn/post/7176644710847479869?searchId=202308121414485195F2B81FDEFB9E9997]
总结：[https://juejin.cn/post/6844904136161361933?searchId=2023081218270962E235F69AAE2CC415D4#comment]
手写：[https://juejin.cn/post/6968713283884974088?searchId=20230815133401D2A1C873B93DE3C4A744]
手写：[https://juejin.cn/post/6946022649768181774?searchId=20230815160309FA533715CC04A5D4D63E]
### JS基础

#### 数据类型
    - 基础类型：：Number、String、Boolean、Null、Undefined、Symbol、BigInt
    - 引用类型：Object、Function、Array、RegExp、Date 基本包装类型及单体内置对象(Global、Math)等
    - 区别：基本数据类型的值保存在栈里面，可以直接访问；引用数据类型保存在堆里面，栈里面保存的是地址，通过栈里面的地址去访问堆里面的值
    - null 和 undefined 的区别：null表示一个对象被定义了，值为“空值”,undefined表示不存在这个值。就是此处应该有一个值，但是还没有定义

#### 数据类型判断方法
    - typeof: typeof可以区分除了Null类型以外的其他基本数据类型，以及从对象类型中识别出函数，但不能识别数组; typeof null返回的是 "object"，原因在底层的js系统中，会通数据的二进制形式的前三位 来判断当前数据的类型是哪一种，如果是 000 会判断为对象，因为 null 在 JS 的最初设计的表现形式的前三位也是 000，所以造成了误判。

    - instanceof： 用来判断引用数据的具体类型，它会将左边实例的隐式原型和右边构造函数的显示原型进行循环比对。看看是否有哪一级能对上，有对的上的就返回true,一直顺着原型链找到头都没有比对成功的，返回false；所以它可以正确判断出引用类型的数据具体属于 Array,Function和Object中的哪一种。

    - Object.prototype.toString.call：这种判断方法是几种方法中判断类型最完善，结果最为准确的方法。
        原理：
            如果调用方法的this的值是undefined，返回"[object Undefined]"。
            如果调用方法的this的值是null，返回"[object Null]"。
            如果是其他值，则先将this的值作为参数传给 ToObject 函数调用并得到结果
            将结果的[[Class]]属性值作为变量class进行拼接，最终的结果是"[object class]"。

            如果this的值是String、Number、Boolean等原始类型，则先把原始类型准换成对应的引用类型，然后获取其引用类型的[[Class]]属性值，即 "String" 、 "Number" 、 "Boolean" 等字符串，然后拼接为"[object String]"、"[object Number]"、"[object Boolean]"。
            如果this的值是Math、Date、RegExp、Error、Function、Array、JSON、Object、Arguments等引用类型，则直接获取其[[Class]]属性值。

            call 方法修改了toString 方法的this指向，将指向从Object改为括号内的值

    - Array.isArray：Array 原型上的方法，用于判断数据是否为数组

#### 类型转换
    - == 和 === 的区别： 双等号只会对两边的值进行判断，遇到不同类型的值会进行隐式类型转换，再进行值的比较；三等号不仅会对比值，也会对比值的类型。

### JS 进阶

#### 作用域和作用域链
    -介绍：
        作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。作用域决定了代码区块中变量和其他资源的可见性。一般可分为：全局作用域、局部作用域（函数作用域）、块级作用域。

    - 分类：
        全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。

        局部作用域：也叫做函数作用域，如果一个变量是在函数内部声明的，它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。
        块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫做块级作用域。

    - 作用域链：
        当在 JS 中使用一个变量时，JS 引擎会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推，直至找到该变量或是查找至全局作用域，如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。


#### 闭包
    - 介绍：在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，它是函数与其词法环境的引用，闭包可以使内部函数访问到外部函数的作用域；当从函数内部返回一个内部函数时，返回的函数将会保留当前闭包，即外层函数的词法环境

    - 原理：一般函数中的变量是存储在栈内存，一般在它的当前执行环境结束就会被销毁和回收；
    而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 
    堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。闭包实际上是一个引用，其的中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量

    - 作用：
        保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
        保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化
    - 问题:
        变量都被保存在内存中，内存消耗很大,容易产生内存泄漏
        会在父函数外部，改变父函数内部变量的值

#### this
    概念：
        this是 JS 的一个关键字，它是函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，this的值会发生变化，但有一个总的原则：this指的是调用函数的那个对象。
    this的指向：
        ① 作为普通函数执行时，this指向window，但在严格模式下this指向undefined。
        ② 函数作为对象里的方法被调用时，this指向该对象.
        ③ 当用new运算符调用构造函数时，this指向返回的这个对象。
        ④ 箭头函数的this绑定看的是this所在函数定义在哪个对象下，就绑定哪个对象。如果存在嵌套，则this绑定到最近的一层对象上。

#### new 的机制
    首先创建了一个新的空对象
    设置原型，将对象的原型设置为函数的prototype对象。
    让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性）
    判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

    ```
    function myNew(fn, ...args) {
        let obj = Object.create(fn.prototype);
        let res = fn.call(obj, ...args);
        if (res && (typeof res === "object" || typeof res === "function")) {
            return res;
        }
        return obj;
    }
    ```
#### 继承的实现方式
    - 链接：[https://juejin.cn/post/6914216540468576263?searchId=20230815142733276166C19224A4B9707D]
    
    1.原型链继承: 将父类的实例作为子类的原型,
    ```
        function Parent() 
        Parent.prototype.getInfo = function() {}

        function Child() {};
        Child.prototype = new Parent()
    ```
    优点：父类方法可以复用
    缺点：父类的所有引用属性（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响
    子类型实例不能给父类型构造函数传参.

    2.构造函数继承:在子类构造函数中调用父类构造函数，可以在子类构造函数中使用call()和apply()方法,
    ​ 通过使用call()或apply()方法，创建Child实例的新对象的上下文执行了Parent构造函数，就相当于新的Child实例对象上运行了Parent()函数中的所有初始化代码.
    ```
        function Parent() 

        function Child() {
          Parent.call(this)
        };

    ```
    优点：可以在子类构造函数中像父类构造函数传递参数,父类的引用属性不会被共享
    缺点：子类不能访问父类原型上定义的方法,所有方法属性都写在构造函数中，每次创建实例都会初始化.

    3.组合继承：组合继承综合了原型链继承和盗用构造函数继承(构造函数继承)，将两者的优点结合了起来。
    基本的思路就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性
    ```
        function Parent(name) {
            this.name = name
            this.colors = ["red", "blue", "yellow"]
        }
        Parent.prototype.sayName = function () {
            console.log(this.name);
        }

        function Child(name, age) {
            // 继承父类属性
            Parent.call(this, name)
            this.age = age;
        }
        Child.prototype = new Parent();
    ```
    优点：父类的方法可以复用，可以在Child构造函数中向Parent构造函数中传参，父类构造函数中的引用属性不会被共享
    缺点：无论什么情况下，父类构造函数都会被调用两次，一是创建子类原型对象时，二是子类构造函数内部。

    4、原型式继承： ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象，通过 Object.create 这个方法可以实现普通对象的继承，不仅仅能继承属性，同样也可以继承方法

    ```
        function Parent() 

        const Child = Object.create(Parent)

    ```
    优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性
    缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染

    5.寄生式继承: 实现——构造函数模式+工厂模式，使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承.

    ```
        function Parent()

        function clone (parent, child) {

            // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
            child.prototype = Object.create(parent.prototype);
            child.prototype.constructor = child;

        }

        const Child = clone(Parent)
    ```
    优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法.

    6、寄生组合式继承: 将寄生式继承和组合继承的优点结合起来，得到寄生组合式继承。
    
    ```
        function inheritPrototype(child, parent) {
            let prototype = Object.creat(parent.prototype); // 创建对象
            prototype.constructor = child; // 增强对象
            Child.prototype = prototype; // 赋值对象
        }

        function Parent(name) {
            this.name = name;
            this.friends = ["rose", "lily", "tom"]
        }
        function Child(name, age) {
            Parent.call(this, name);
            this.age = age;
        }
        inheritPrototype(Child, Parent);
    ```
    算是引用类型继承的最佳模式，解决了之前几种方式的父类构造函数多次调用，无法传参，父类方法无法复用，父类属性被共享的问题
#### 原型和原型链
    - 链接：https://juejin.cn/post/6844903989088092174?searchId=20230815135502E7204A82960660C8F11B#comment
    - 举例
        ```
             function Person(name, age){ 
                this.name = name;
                this.age = age;
            };
            let person01 = new Person('小明', 18);

            Person.prototype.constructor == Person // 原型对象（即Person.prototype）的constructor指向构造函数本身

            person01.__proto__ == Person.prototype //实例（即person01）的__proto__和原型对象指向同一个地方

            Object.prototype._proto_ = null

            Function.prototype._proto_ = Object.prototype
        ```

#### call、apply、bind
    - call:该函数接受多个参数，第一个参数是指定的是 调用call方法的函数的this指向，a.call(b),那么就是把 a函数和里面变量的this指向b，既 b调用了 方法；剩下的参数是函数调用时需要传递的参数。call改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次。
    - apply：该函数接受两个参数，第一个参数是指定的this的指向，第二个参数是函数接受的参数，以数组的形式传入。改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次。
    - bind：该函数的第一参数也是指定的this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)。bind 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数，需要手动调用。

#### 数组方法
    - slice / splice(有p则改原数组)
        1. slice 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改.
        2. splice() 方法用于添加或删除数组中的元素, 参数包括三个部分，开始的下标，删除的个数和添加的新元素，这个方法会改变原数组。

    - array.flat:数组扁平化方法，参数分别是需要扁平的数组和扁平的层数。
    ```
        function func(array) {
            let newArr = []
            const rec = (arr) => {
            arr.forEach(item => {
                if (!Array.isArray(item)) {
                    newArr.push(item)
                } else {
                        rec(item)
                    }
                })
            }
            rec(array)
            return newArr
        }
    ```
    - sort: sort()方法对数组元素进行排序，并返回这个数组，可以传入一个排序顺序的比较函数来进行排序

    - forEach: forEach()没有返回值，本质上等同于 for 循环，对每一项执行 function 函数，forEach 是不改变原数组，除非回调函数中有改变原数组的操作

    - map: 创建一个新数组，其结果是原数组中的每个元素都调用一个提供的函数后返回的结果，参数是用于处理数据的函数，函数中参数分别为数组当前元素的值，当前元素的索引值和数组对象本身。

    - some/filter: some数组中的是否有满足判断条件的元素，如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测。filter可以返回一个新数组, 该数组中的元素是原数组中满足传入函数的判断条件的所有数据。

    - reduce: reduce()方法将会对数组元素从左到右依次执行reducer函数，然后返回一个累计的值.reduce方法将会对数组元素从左到右依次执行reducer函数，然后返回一个累计的值。该方法接收两个参数，第一个参数是回调函数reducer，第二个参数是初始值。reducer函数接收四个参数：
        total: 当传入初始化值之后，第一次运行时 total即为初始值, 运行之后，total 即为目前累计操作的元素集合
        currentValue: 调用ruduce方法的数组的当前元素值
        currentIndex: 调用ruduce方法的数组的当前元素下标
        arr:用ruduce方法的数组对象、
    通过 reducer可以进行数组累加，去重，扁平化等多种操作

#### for in / for of
    1.for of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象（iterator）的集合，但是不能遍历对象，因为没有迭代器对象，
    它遍历的只是数组内的元素，不包括原型属性和索引。
    2.for in 会遍历对象所有的可枚举属性，包括原型。遍历数组的话得到的是下标的字符串集合，所以不适合直接遍历数组

#### 深浅拷贝
    - 浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址。常用的方法有：object.assign，扩展运算符
    - 深拷贝：深拷贝是创建一个新的对象，该对象与原始对象完全独立，在内存中占据不同的位置。深拷贝会复制原始对象的所有属性和嵌套对象，并且对其中一个对象的修改不会影响到另一个对象，快捷的方法：JSON.parse(JSON.stringify(obj))

#### 防抖/节流
    - 防抖：多次触发事件，事件处理函数只执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发，准备执行事件函数前，会等待一定的时间，在这个等待时间内，如果没有再次被触发，那么就执行，如果又触发了，那就本次作废，重置等待时间，直到最终能执行。

    - 节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。

    - 应用场景：防抖适用于搜索框搜索输入，用户最后一次输入完，再发送请求；手机号、邮箱验证输入检测，
    节流适用于 高频点击、表单重复提交等场景。

#### event loop 事件循环
    - 同步/异步:
        1.基于js的单线程同时只能处理一件事情，而同步即是在主线程上排队执行的任务，只有当前任务执行完成，才会进入下一个任务。同步执行的函数会在预期得到结果，也就是可以清楚什么时候能得到返回值.
        2.异步是指当前执行的代码会进入异步线程处理之后才会再由主线程处理回调,
        异步代码不是直接放在调用栈中执行，而是要派发(可能不需要)给其他线程处理，等处理完成后的回调放在某个地方存储(比如任务队列)，等到同步队列执行完成之后才会取回异步回调代码进行执行

    - 宏任务/微任务:
        1.宏任务队指的是WebApis的回调，WebApis中包含许多线程，GUI渲染线程(与js主线程互斥不能同时执行)、事件触发线程、定时器线程、异步网络请求线程，这些宏任务会存储在宏任务队列中，执行的优先级低于微任务队列。
        2.微任务可以由这些方法关键字调用产生Promise、async、await、MutaionObserver、process.nextTick，主线程优先执行全部微任务，待执行完成之后才会挨个执行宏任务。

    - 过程：
        通常浏览器在最开始运行js代码的入口就是html中的script标签所涵盖的代码；

        当GUI渲染线程解析到script标签，则会把标签所涵盖的js代码加入到宏任务队列中；

        首先js引擎(如V8引擎)先取第一个宏任务，即script的代码块，然后主线程在调用栈中解析js代码
          等所有代码解析完成之后开始运行js代码；

        如果遇到同步代码直接执行，遇到异步代码，如果是宏任务类型即异步WebApis处理的异步代码，那么将会通知WebApis在对应的线程中处理异步任务，此时js主线程继续执行下面的代码，在其他线程处理完毕之后如果有回调函数，则异步线程会将回调函数加入到宏任务队列尾部；

        如果是微任务类型的异步代码，也同宏任务处理，只不过是把回调函数加入到微任务队列中，其执行的优先级高于宏任务队列；

        当同步代码全部执行完成，主线程将会一直检测任务队列，如果有异步微任务则执行完全部的微任务
        进一步执行浏览器渲染进程绘制页面，之后就是开始下一轮的事件循环，就又回到取宏任务执行

#### JS垃圾回收机制
    -资料：[https://juejin.cn/post/6981588276356317214?searchId=202308151657503DBFEFDD80F030D1A49F]

    - 介绍：程序工作过程中会产生很多垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，引擎内部会进行内存空间的回收，既为垃圾清除。这个过程中的重点那就是怎样找出所谓的垃圾？这个流程就涉及到了一些算法策略，有很多种方式。

    - 策略
        1.标记清除算法：目前在 JavaScript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异。

        此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。

        整个过程中，垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
        然后从各个根对象开始遍历，把不是垃圾的节点改成1
        清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
        最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

        优点：实现简单
        缺点：除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了内存碎片，这种碎片不利于内存的再分配

        优化：标记整理（Mark-Compact）算法 就可以有效地解决上述问题，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存

        2.引用计数算法：这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法

        它的策略是跟踪记录每个变量值被使用的次数

        当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1；
        如果同一个值又被赋给另一个变量，那么引用数加 1；
        如果该变量的值被其他的值覆盖了，则引用次数减 1；
        当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存。

        优点：实现简单，引用计数在引用值为 0 时，垃圾会被立即回收，不需花费时间去对比和计算。
        缺点：无法解决循环引用的计数问题，造成大量的内存不会被释放

        优化：分代式垃圾回收，V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

        新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，
        老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大

        新生代回收：算法会将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作，
        当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区；
        当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

        老生代回收：老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器用标记整理来管理其垃圾回收执行
#### JS内存泄漏
    - 介绍：内存泄漏一般是指系统进程不再用到的内存，没有及时释放，造成内存资源浪费，导致程序运行速度减慢甚至系统崩溃等严重后果
    - 可能原因：
        1.全局变量：在局部作用域中，函数执行完毕后，变量就没有存在的必要了，垃圾回收机制很快的做出判断并回收；但是对于全局变量，很难判断什么时候不用这些变量，无法正常回收。
        解决办法：
            ① 尽量少使用全局变量；
            ② 使用严格模式，在 js 文件头部或者函数的顶部加上use strict。

        2.闭包引起的内存泄露：闭包可以读取函数内部的变量，然后让这些变量始终保存在内存中，如果在使用结束后没有将局部变量清除，就可能导致内存泄露。
        解决办法：将事件处理函数定义在外部，解除闭包。

        3.被遗忘的定时器：定时器setInterval或者setTimeout不再需要使用时，且没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，就会造成内存泄漏。
        解决办法：当不需要定时器的时候，调用clearInterval或者clearTimeout手动清除。

        4.没有及时清除的事件监听：垃圾回收机制不好判断事件是否需要被解除，导致callback不能被释放，此时需要手动解除绑定。
        解决办法：及时使用removeEventListener移除事件监听。


### ES6/7 新特性
#### let const 

    - let：用于声明一个块级作用域的变量。与以前的var关键字不同，let声明的变量只在其所在的块级作用域内有效，而不会被提升到函数作用域。这意味着在使用let声明的变量之前，必须先进行声明。
    - const关键字用于声明一个常量，其值在声明后不能再改变。const声明的变量也是块级作用域的，与let类似，但其值是不可变的

#### 箭头函数
    - 在ES6语法之前，JS中的函数由function关键字、params参数和被花括号包裹的函数体组成, 而箭头函数作为Es6新增的一种定义函数表达式的语法，它的赋值式写法和两种括号的省略简化了我们之前写的函数书写方式，但两者最大的区别体现函数this的指向。

    - 普通函数在调用时，它的this指向的是所处的上下文对象或是调用对象，

    而在箭头函数中，它不会创建自己的this,它只会从自己的作用域链的上一层继承this，当我们使用时，它会默认帮我们绑定外层普通函数this的值，所以在箭头函数中this的指向和外层的this指向是一样的，如果箭头函数外层没有普通函数可以继承，在全局作用域下，严格模式和非严格模式下它的this都会指向window对象；

    除了this,它的 arguments 参数类数组也是继承于外层的普通对象，在this 指向 window的情况下，直接在箭头函数里访问 arguments，会出现未声明的的错误

    当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上，箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用会报错，因为不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性，为了减少箭头函数中this的复杂性，无法用call方法来指定它的this。

####  map 和 set
    - Map方法 可以构造键值对的集合(Hash 结构)，它实现了类似于字典的数据结构。表现上类似于对象，但有一些不同之处。Map的键可以是任意类型的值，包括对象和函数，而对象只能使用字符串作为键。此外，Map的键值对是有序的，插入顺序决定了键值对的顺序。它通过 get和set 来查找数据和新增数据，通过的delete 和clear 来删除特定的值和清空整个 map,通过 has方法判断map里是否存在特定的键值对，也可以使用 keys, values 和forEach()分别来遍历 map 里的 键名，数值和所以对象。

    - Set方法可以构造特殊的值的集合，实现了类似于集合的数据结构，它由一组无序且唯一(即不能重复)的项组成的，它的键是它的值本身，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组。Set可以存储任意类型的值，包括原始类型和对象， 可以使用 add 和 delete 分别来添加和删除一个值，类似用于map,也可以使用 has 来判断set里是否存在特定的值，使用clear移除所以的项，遍历的方法和 map 也类似。

#### weakMap 和 weakSet

    -  WeakMap类似于map,它也是一种键值对的集合，但是只接受对象作为键，不接受其他类型的数据。WeakMap中的键是弱引用的，这意味着如果键对象没有其他引用，它会被垃圾回收机制回收，并且对应的键值对也会从WeakMap中被自动移除。

    - WeakSet类似于 set， 它是一种弱引用集合，它只能存储对象类型的值，并且这些对象是弱引用的。这意味着如果一个对象在WeakSet中没有任何其他引用，那么这个对象将会被垃圾回收。由于WeakSet的成员是弱引用，因此无法迭代，也无法获取其中的大小或者清空它。

#### promise

    - Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。它比传统的异步解决方案【回调函数】和【事件】更合理、更强大。传统的回调事件处理异步的方法面对复杂的业务场景处理多个请求时可能需要将回调事件进行多次嵌套，这样会带来代码臃肿，可读性差，维护性低的回调地狱，promise的出现解决了这种问题。

    - promise首先重要的是它的三个状态 pending(等待态)，fulfiled(成功态)，rejected(失败态)， 初始状态是 
     等待状态，它可以转变成 成功态或失败态，一旦转变完成，则状态不能再改变

    - 其次关于promise的是状态改变的方法和状态改变后的处理，当我们new一个promise时，需要传递一个立即执行的回调函数，函数的两个参数是改变当前 promise 状态的两个方法， 
        resolve 方法会根据传入值的不同来决定当前Promise状态是如何改变的，如果传入的是普通的值或者对象，resolve 方法返回的是一个带有传入值的成功状态的promise,当前promise的状态变为成功；
        如果resolve中传入的是另外一个Promise，那么这个新Promise的结果会决定原Promise的状态；如果传入的是一个有then方法的对象，那么resolve中会执行该then方法，此时的promise状态取决于then方法中调用了resolve，reject函数；

        调用reject 方法则是直接返回一个失败状态的Promise，当前promise的状态变为rejected，传入reject中的参数会作为失败的信息被 then 捕获

        当promise 中执行了resolve或reject 方法后，它返回的是一个带有执行结果和新状态的Promise对象，还需要进一步地处理， 每个Promise都存在一个then方法用于处理resolve或reject的返回，then可以传入两个回调函数来处理Promise的结果。如果 Promise 的结果是 resolve，第一个调用函数会被调用并传入 resolve 的结果作为参数；如果 Promise 的结果是 reject，第二个函数会被调用并传入 reject 的错误信息作为参数，
        then 返回的是一个新的 Promise，该 Promise 的状态由回调函数的返回值决定。如果回调函数返回的是一个普通值，那么这个 Promise 对象 状态为 成功状态，如果返回的是一个 Promise对象，那么回调函数返回的Promise 状态将 then 返回的Promise 的状态相同。如果回调函数抛出错误，那么新 Promise 的状态将为 rejected，需要通过 try catch 捕获错误。
        通过这种设计可以完成异步任务使用then进行链式调用，解决Es6之前的回调嵌套问题

        异步任务会因为多种原因失败，而promise中使用 catch 方法进行错误的捕获，它和then的第二个参数相同，用来指定reject的回调，catch回调中可以获取到reject 的抛出的错误信息，同时它于try/catch语句有相同的功能，当我们在执行resolve的回调时，如果抛出异常了会让js 程序卡死，在 then 返回后面使用catch会让错误被捕获，不影响后续程序运行。

    - promise还内置了两个方法方便批量的异步请求处理，
        1.Promise.all 方法接收一个 Promise 数组，返回一个新的 Promise 对象。该 Promise 对象的状态由数组中的元素决定。如果数组中所有元素的  状态都为 fulfilled，则 Promise 对象的状态为 fulfilled，这个对象的结果为数组中所有数据的集合
        
        2.Promise.race 方法接收一个 Promise 数组，返回一个新的 Promise 对象。该 Promise 对象的状态由数组中最先返回结果的元素决定。

#### async/await

    - 当我们使用promise 方式去解决网络请求的嵌套问题时也会不可避免的带来在其中的链式调用太多， 而async/await 方法可以帮助我们用同步的书写方式去编写异步代码，在async函数中，可以使用使用 await 关键字对异步操作进行声明，当 async函数里有多个 await限定的异步操作时，它们的执行顺序就是 await 声明的顺序，且上一个异步操作的执行会阻塞下一个操作。