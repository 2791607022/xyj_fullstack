### css 基础

#### css 盒模型
    - 盒子模型就是 元素在网页中的实际占位，有两种：标准盒子模型和IE盒子模型
    - 标准(W3C)盒子模型：内容content+填充padding+边框border+边界margin，宽高指的是 content 的宽高
    - 低版本IE盒子模型：**内容（content+padding+border）+ 边界margin，宽高指的是 content+padding+border 部分的宽高
#### css选择器和优先级
    - 选择器
        id选择器(#myid)
        类选择器(.myclass)
        属性选择器(a[rel="external"])
        伪类选择器(a:hover, li:nth-child)
        标签选择器(div, h1,p)
        相邻选择器（h1 + p）
        子选择器(ul > li)
        后代选择器(li a)
        通配符选择器(*)
    
    - 优先级：带!important 标记的样式属性优先级最高； 样式表的来源相同时：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性
        !important
        内联样式（1000）
        ID选择器（0100）
        类选择器/属性选择器/伪类选择器（0010）
        元素选择器/伪元素选择器（0001）
        关系选择器/通配符选择器（0000）
#### position 属性和其区别

    - absolute：生成绝对定位的元素，相对于static定位外的父元素进行定位。位置通过left、top、right、bottom属性进行规定。
    - relative：生成相对定位的元素，相对于其原来的位置进行定位。
    - fixed：生成绝对定位的元素，该元素相对于屏幕视⼝（viewport）的位置来定位。它的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。
    - static：默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。
    - inherit：规定从父元素继承position属性的值。
    -sticky:基于用户的滚动位置来定位,粘性定位的元素是依赖于用户的滚动，需要指定 top, right, bottom 或 left 四个值其中之一，才会生效。否则与相对定位相同。
#### px, em/rem, vw/vh

    - px: 像素单位是相对于屏幕分辨率而言的，对同一设备来说它是绝对的, 但对于不同设备来说它是相对的。

    - vw/vh: vw 和 vh 是 CSS3 新单位，即 view width 可视窗口宽度 和 view height 可视窗口高度。1vw/1vh 相当于可视窗口宽高的百分之一。
    - em/rem: em是文本相对长度单位。它相对的是父元素内文本的font-size；rem是CSS3新增的一个相对单位，它相对的是根元素既html元素的font-size。

    - 使用场景：px是固定的像素，一旦设置了就无法因为适应页面大小而改变，一般用于只需要适配少部分移动设备的页面，且分辨率对该页面影响不大；对于需要适配各种移动设备的项目，使用em/rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。

#### BFC
    - 介绍：BFC（Block Formatting Context）既为“块级格式化范围”，它决定了该环境下的内容如何进行定位，以及其中的内容与其他html元素的关系和相互作用。
    BFC内部的元素会在垂直方向放置，上下相邻的两个元素的margin会重叠，内部每个元素左margin与BFC环境的左border接触；对于BFC外部的元素来说，BFC 是页面上的一个隔离的独立容器，外部元素与BFC容器里面的子元素互不干涉。

    - 如何生产一个BFC区域：
        1. html 根元素为BFC元素
        1. 对元素设置 float 浮动
        2. 对元素设置 overflow auto、scroll、hidden效果
        3. 将元素定位设置为绝对定位和fixed定位
        4. 将dispaly 属性设置为table-cell, table-caption, inline-block

    - 作用：
        1.解决浮动元素令父元素高度坍塌的问题：一个未设置高度普通容器中含有浮动子元素的时候，容器的高度并不会被子元素撑高，而会坍陷，这时可以将该容器设置为BFC元素来解决
        2.解决非浮动元素被浮动元素覆盖问题：如果浮动元素后面有一个非浮动的元素，那么会产生现象，非浮动元素会包裹在浮动元素周围，可以通过对非浮动元素设置BFC来解决，常见的左右两栏布局就是这个原理。
        3.解决外边距垂直方向重合的问题：在BFC元素内部的两个相邻容器的上下 magin 会发生重叠，导致距离有误，这时可以对其中一个容器设置BFC,解决重叠问题。

#### 重绘和重排

    - 介绍：
        重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算时触发，表现为重新生成布局，重新排列元素。
        重绘: 节点的几何属性发生改变或者样式发生改变时触发，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变。
    
    - 问题：重排和重绘代价高昂，破坏用户体验，并且让UI展示变的迟缓，重排的性能影响高于重绘，且重排一定会引起重绘。

    - 如何避免
        1.集中改变样式，不要一条一条地修改 DOM 的样式。
        2.避免直接进行添加、删除、更新DOM节点等操作，不要把 DOM 结点的属性值放在循环里当成循环里的变量。
        3.为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
        4.不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
        5.尽量只修改position：absolute或fixed元素，对其他元素影响不大

#### css属性的继承性
     - 无继承性的属性：display 属性；部分文本属性 包括 vertical-align，text-shadow等；盒子模型的属性，包括 宽高，边框和内外边距；背景属性，定位属性 等
     - 可继承性的属性：字体系列的属性包括字体的系列，大小，粗细和风格；文本系列属性包括文本的缩进，水平对齐，行高，颜色等，元素的 visibility 可见性。

####  伪元素和伪类的区别和作用
    - css3 中写法有区别：冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。
    - 伪类选择元素时基于的是当前元素处于的状态，当元素达到特定状态时，会获得伪类的样式；当状态改变时，又失去伪类样式。伪类功能和class有类似，它是基于文档之外的抽象，所以叫伪类。
    - 伪元素是对元素中的特定内容进行操作，操作的层次比伪类更深，所以它的动态性比伪类更低，它可以用于选取诸如元素内容第一个字（母）、第一行等具体内容，它本身是基于元素的抽象，并不存在于文档中，所以叫伪元素。

    使用场景:当链接，按钮，文本等元素处于选中，鼠标悬浮和被点击等状态时，可以使用伪类对其添加特殊样式，提升用户体验；伪元素可以用于对文本进行首字母，首行强调等特殊操作，也可以进行清除浮动元素引起的问题。

####  css引入方式link和@import的区别

    -从属关系区别： @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。
    - 加载顺序：link是异步操作 GUI渲染页面遇到link会开辟新的HTTP线程去获取资源 GUI继续渲染页面；@import 是同步的 渲染页面的时候遇到@import会等它获取到资源后继续渲染。
    - 兼容性区别：@import是 CSS2 以上的语法，所以只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在浏览器兼容性问题。
    - DOM可控性区别：可以通过 JS 操作 DOM ，动态插入link标签来改变样式；而无法动态使用@import的方式插入样式。
#### css动画效果
    - transition 过渡效果：它表示的是某个元素属性从一个值转变为另一个值，它是一个状态的转变，并需要相关动作来触发。例如用到的:hoever、:focus、:checked 等过渡效果的产生需要事件触发，无法自动发生，所以它也一次性的，同时它只能定义开始状态和结束状态，其中有四个属性：property，duration，timing-function，delay 分别设置了过渡效果的 CSS 属性的名称，过渡效果的周期，过渡度效果的速度曲线和事件触发后延迟多长时间开始过渡

    - animation 则是transition属性的扩展，弥补了transition的很多不足，它可以单独设置动画过程中每个时间点的效果，从而控制动画的整个时间轴，同时支持设置 动画的播放次数，播放状态，播放结束后的操作，以此实现更复杂的动画效果。
    animation中， name属性即为定义好的动画样式名称，它需要用@keyframes 来声明，除去duration，timing-function，delay 外，animation 还可以使用iteration-count 来指定动画播放的次数；使用direction 来规定动画的播放方向是正向还是反向；设置play-state来确定动画目前的播放或暂停状态；最后fill-mode在动画结束后让时间轴 停留在结束时刻或者回到开始或者回到第一帧。

### css实际场景

#### css 实现多行文本溢出省略
    - 单行文本溢出:
        ```
            overflow: hidden;       // 溢出隐藏
            text-overflow: ellipsis;   // 溢出用省略号显示
            white-space: nowrap;   // 规定段落中的文本不进行换行
        ```

    - 多行文本溢出:
        ```
            overflow: hidden;            // 溢出隐藏
            text-overflow: ellipsis;     // 溢出用省略号显示
            display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
            -webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
            -webkit-line-clamp:3;        // 显示的行数
        ```
#### 实现水平垂直居中的方式
    - 利用  transform实现：父元素的定位为relative,需要水平垂直居中的元素的定位设置为绝对定位，
    元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过来 transform: translate(-50%,-50%) 调整元素的中心点到页面的中心
    
    { //需要水平垂直居中的元素
        position: absolute;
        top:50%;
        left:50%;
        transform: translate(-50%,-50%)
    }

    - 利用margin: auto实现：子元素设置为绝对定位，设置四个方向的值都为0，并将margin设置为auto，子元素有宽高的情况下，边距会在对应方向实现平分。该方法适用于盒子有宽高的情况

    { //需要水平垂直居中的元素
        position: absolute;
        top:0;
        left:0;
        bottom：0；
        right：0；
        margin: auto
    }

    - 利用设置 magin 为负值实现：利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过设置margin left/top 为元素宽高的负50% 来调整元素的中心点到页面的中心。该方法适用于盒子宽高已知的情况

    { //需要水平垂直居中的元素
        position: absolute;
        top:50%;
        left:50%;
        margin-left: -50% * 元素宽度
        margin-top: -50%  * 元素高度
    }

    - 使用flex布局实现：父元素的display设置为 flex; 设置justify-content:center 使得子元素在主轴方向居中，设置align-items:center 是子元素在主轴垂直方向居中

     { //父元素
        dispaly:flex;
        justify-content:center
        align-items:center 是子元素在主轴垂直方向居中
     }

#### CSS 实现三角形
    - CSS绘制三角形主要用到的是border属性，也就是边框，平时设置边框时，往往设置很窄，会误以为边框是由矩形组成的。实际上，border是由三角形组成的。
    - 设置一个三角形，首先需要一个宽高为0的容器，然后单独设置border的上下左右其中一边的大小，形状和颜色，另外三边边框的前两个属性和之前相同，但颜色需要设置为透明
    ```
    div {
            width: 0px;
            height: 0px;
            border-top: 100px solid #ff0;
            border-right: 100px solid transparent;
            border-left: 100px solid transparent;
            border-bottom: 100px solid transparent;
        }
    ```
#### 清除浮动的方式
    - 浮动的定义： 父元素不设高度且子元素设置了 float属性时，父元素高度没有被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动。
    -问题：
        浮动元素会引起父元素同级的元素，
        与浮动元素同级的非浮动元素会跟随其后
        若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构
    - 清除方法：
        1.父元素高度：给父级div定义一个具体的高度，而不是期望用子元素去撑高
        2.额外标签：最后一个浮动元素之后添加一个空的div标签，并添加clear:both 样式
        3.BFC：给父级标签添加overflow:hidden或auto，或者父元素也浮动，或设置display:table, 将父元素设置为BFC元素
        4.::after 伪元素，给浮动容器设置一个内容为空的after 伪元素，::after内使用 display 将 该伪原素设置为块级元素，然后使用 clear: both  
        ::after {
            content: " ";
            display：block;
            height: 0;
            visibility: hidden;
            clear: both;
        }

#### 隐藏元素的方法和区别
    1.opacity：0，元素隐藏但不改变页面布局，如果该元素已经绑定了一些事件，如click ，那么点击该区域仍然能触发该事件。
    2.visibility：hidden，元素隐藏起也不改变页面布局，但不触发元素绑定的事件，会在文档布局中仍保留原来的空间会造成页面重绘。
    3.display：none，元素隐藏且改变页面布局，在文档布局中不再分配空间，使用后造成页面回流+重绘。
    4.position: absolute：通过使用绝对定位将元素移动到可视区域外，以实现隐藏。
    5.z-index: 负值：来使其他元素遮盖住该元素，以实现隐藏。

### css 布局

#### flex布局

    -  定义：Flex是FlexibleBox的缩写，意为"弹性布局"，通过将元素的display属性值设置为flex使它成为一个flex容器，其中的子元素都会成为它的项目。flex容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。
    - 主属性
        1.flex-direction 指定主轴的方向。
        2.justify-content 指定元素在主轴上的排列方式。
        3.align-items 指定元素在交叉轴上的排列方式。
        4.flex-wrap 规定当一行排列不下时的换行方式。
    - 子元素属性：
        1.order属性 指定项目的排列顺序。
        2.flex-grow 指定当排列空间有剩余的时候，项目的放大比例。
        3.flex-shrink 指定当排列空间不足时，项目的缩小比例。
        4.flex-basis 指定子元素在主轴方向上的初始大小。

#### 两栏、三栏布局
    -  两栏布局:指的是左边一栏宽度固定，右边一栏宽度自适应，常见于普通的后台系统。
         设计：左边的元素需要设置一个固定宽度，并且设置向左浮动， 右边元素的margin-left设置左边元素的宽度，自身的宽度设置为auto，用于撑满父容器剩余的宽；或者直接将右边区域使用overflow: hidden 属性，利用BFC避免左右重叠。除了浮动方式，也可以使用 flex布局，父元素的display设置为 flex,右边元素直接设置flex:1 使其占满剩余的右边空间。
    - 三栏布局:三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局.它的实现和两栏布局的方法原理上一致，也可以使用 浮动+magin方式，flex布局，绝对定位+布局来实现。
### css 优化/适配/预处理

#### css 适配
    移动端适配主要有两个维度：
        适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；
        适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。

#### css 媒体查询的理解

    - 媒体查询CSS3的概念，允许呈现的内容针对⼀个特定范围的显示设备⽽进⾏裁剪，⽽不改变内容本身，适用于web⽹⻚对不同型号设备进行响应式适配。

    - 它包含⼀个可选的媒体类型和满⾜CSS3规范的条件表达式，其中媒体类型分为移动端可pc端，表达式则是设备物理属性的判断条件，包括像素密度，屏幕大小等。如果当前设备类型与媒体查询中指定的类型相匹配，并且所有表达式的值都是true的话，那么该媒体查询的结果为true。其中的样式将会在该设备上生效，通过它可以对不同设备进行样式的特殊处理，达到页面的适配。

#### css 预处理器/后处理器

        - 预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加css代码的复用性。
        它们为css增加一些编程特性，例如支持在CSS中使用变量，简单的逻辑程序，函数等编程语言的基本性能。能让css更加的简洁，增加cssd的适应性，可读性，可维护性。预处理器中的层级，mixin， 变量，循环， 函数等都对编写以及开发UI组件都非常有用。

        -  PostCSS：PostCSS 本体的功能比较单一，它提供了一种用 Js 处理 CSS 的方式。它会把 CSS 解析成 AST（Abstract Syntax Tree 抽象语法树），将AST再用其他插件进行不同的处理，它常用做给CSS属性添加浏览器私有前缀，解决跨浏览器的兼容问题。它拥有插件系统完善，扩展性强，功能齐全等优点，但配置相对复杂。

        - Sass 在完全兼容 CSS 语法的前提下，给 CSS 提供了变量、嵌套、混合、操作符、自定义函数等可编程能力，sass使用广泛,功能支持完善,可编程能力强;但过度使用会使CSS 的复杂度变动难以控制。

        - Less 和 Sass 类似，完全兼容 CSS 语法，并给 CSS 提供了变量、嵌套、混合、运算等可编程能力。Less 通过 JavaScript 实现，可在浏览器端直接使用。less 使用广泛，容易实现主题定制功能，但不支持自定义函数，编程能力比sass更弱。

        -Stylus 基础功能和 Sass / Less 十分类似，它的特点是冒号、分号、逗号和括号都是可选项，所以可以用它写出非常简洁的 CSS。


