### css 基础

#### css 盒模型
    - 盒子模型就是 元素在网页中的实际占位，有两种：标准盒子模型和IE盒子模型
    - 标准(W3C)盒子模型：内容content+填充padding+边框border+边界margin，宽高指的是 content 的宽高
    - 低版本IE盒子模型：**内容（content+padding+border）+ 边界margin，宽高指的是 content+padding+border 部分的宽高
#### css选择器和优先级
    - 选择器
        id选择器(#myid)
        类选择器(.myclass)
        属性选择器(a[rel="external"])
        伪类选择器(a:hover, li:nth-child)
        标签选择器(div, h1,p)
        相邻选择器（h1 + p）
        子选择器(ul > li)
        后代选择器(li a)
        通配符选择器(*)
    
    - 优先级：带!important 标记的样式属性优先级最高； 样式表的来源相同时：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性
        !important
        内联样式（1000）
        ID选择器（0100）
        类选择器/属性选择器/伪类选择器（0010）
        元素选择器/伪元素选择器（0001）
        关系选择器/通配符选择器（0000）
#### position 属性和其区别

    - absolute：成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定
    - relative：生成相对定位的元素，相对于其原来的位置进行定位
    - fixed：生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式
    - static：默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。
    - inherit：规定从父元素继承position属性的值
    -sticky:基于用户的滚动位置来定位,粘性定位的元素是依赖于用户的滚动，需要指定 top, right, bottom 或 left 四个值其中之一，才可使粘性定位生效。否则其行为与相对定位相同
#### px, em/rem, vw/vh

    - px: 像素是相对于屏幕分辨率而言的，对于同一个物理设备来说它是一个绝对单位, 但对于不同设备来说它具有一定的相对性

    - vw/vh: vw 和 vh 是 CSS3 新单位，即 view width 可视窗口宽度 和 view height 可视窗口高度。1vw 就等于可视窗口宽度的百分之一，1vh 就等于可视窗口高度的百分之一

    - em/rem: em是文本相对长度单位。相对于父元素内文本的字体尺寸；rem是CSS3新增的一个相对单位，相对于根元素既html元素的font-size的倍数

    - 使用场景：px是固定的像素，一旦设置了就无法因为适应页面大小而改变，一般用于只需要适配少部分移动设备，且分辨率对页面影响不大的项目；对于需要适配各种移动设备，使用em/rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备

#### BFC
    - 介绍：BFC（Block Formatting Context）直译为“块级格式化范围”，是W3C CSS 2.1 规范中的一个概念，这个概念决定了该环境下的内容是如何进行定位，以及该环境下的内容与其他html元素的关系和相互作用。
    对于内部来说，BFC内部的元素会在垂直方向上一个接一个放置，上下相邻的两个元素的margin会重叠，内部每个元素左margin与BFC环境的左border接触；
    对于BFC外部的元素来说，BFC 是页面上的一个隔离的独立容器，与BFC容器里面的子元素互补干涉。

    - 如何生产一个BFC区域：
        1. html 根元素为BFC元素
        1. 对元素设置 float 浮动
        2. 对元素设置 overflow auto、scroll、hidden效果
        3. 将元素定位设置为绝对定位和fixed定位
        4. 将dispaly 属性设置为table-cell, table-caption, inline-block

    - 作用：
        解决浮动元素令父元素高度坍塌的问题：一个未设置高度普通容器中含有浮动子元素的时候，容器的高度并不会被子元素撑高，而会坍陷，这时可以将该容器设置为BFC元素来解决
        解决非浮动元素被浮动元素覆盖问题：如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，非浮动元素会包裹在浮动元素周围，可以通过对非浮动元素设置BFC来解决此问题，常见的左右两栏布局就是这原理。
        解决外边距垂直方向重合的问题：在BFC元素内部的两个相邻容器的上下 magin 会发生重叠，导致距离有误，这时可以对其中一个容器设置BFC,解决重叠问题

#### 重绘和重排

    - 介绍：
        重排: 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素
        重绘: 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变
    
    - 问题：重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，重排的性能影响高于重绘，且重排的过程一定会引起重绘。

    - 如何避免
        集中改变样式，不要一条一条地修改 DOM 的样式。

        避免直接进行添加、删除、更新DOM节点等操作，不要把 DOM 结点的属性值放在循环里当成循环里的变量。

        为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。

        不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。

        尽量只修改position：absolute或fixed元素，对其他元素影响不大

#### css属性的继承性
     - 无继承性的属性：display 属性；部分文本属性 包括 vertical-align，text-shadow等；盒子模型的属性，包括 宽高，边框和内外边距；背景属性，定位属性 等
     - 可继承性的属性：字体系列的属性包括字体的系列，大小，粗细和风格；文本系列属性包括文本的缩进，水平对齐，行高，颜色等，元素的 visibility 可见性。
####  伪元素和伪类的区别和作用
    - 在 css3 中伪元素和伪类的写法有区别，冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素
    - 伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，当一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类
    - 伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行等具体内容，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素

    - 当链接，按钮，文本等元素处于选中，鼠标悬浮，被点击等状态时，我们可以使用伪类对它们添加一些特殊的样式，提升用户体验；伪元素可以用于对文本进行首字母，首行强调等特殊操作，也可以进行清除浮动元素引起的问题
####  css引入方式link和@import的区别

    -从属关系区别： @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等
    - 加载顺序：link是异步操作 GUI渲染页面遇到link会开辟新的HTTP线程去获取资源 GUI继续渲染页面；@import 是同步的 GUI渲染页面的时候遇到@import会等它获取新的样式回来后继续渲染。
    - 兼容性区别：@import是 CSS2 以上才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在浏览器兼容性问题
    - DOM可控性区别：我们可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，我们无法动态使用@import的方式插入样式
#### css动画效果
    - transition 过渡效果：字面意思上来讲，就是某个元素从一些属性的值转变为另一个值，这是一个状态的转变，需要一种条件来触发这种转变，比如我们平时用到的:hoever、:focus、:checked，这种过渡效果的产生需要事件产生，无法在网页加载时自动发，所以它也一次性的，同时它只能定义开始状态和结束状态，它有四个属性property，duration，timing-function，delay 分别设置了过渡效果的 CSS 属性的名称，过渡效果的周期，过渡度效果的速度曲线和事件触发后延迟多长时间开始过渡

    - animation 则是transition属性的扩展，弥补了transition的很多不足，它可以单独设置动画过程中每个时间点的效果从而达对动画整个时间轴进行控制，并且可以自定义动画的播放次数，播放状态，播放结束后的操作，以此实现更复杂的动画效果。
    在 animation中 name属性即为定义好的动画样式名称，这段动画样式需要用@keyframes 来声明，除去duration，timing-function，delay 外，animation 使用iteration-count 来指定动画播放的次数，使用direction 来规定动画播放方向，可以让动画在按照时间轴正反方向进行或轮流播放，设置play-state来确定动画目前的播放或暂停状态，最后fill-mode可以让动画结束后时间轴回到开始，停留在结束时间或回到第一帧

### css实际场景

#### css 实现多行文本溢出省略
    - 单行文本溢出:
        ```
            overflow: hidden;       // 溢出隐藏
            text-overflow: ellipsis;   // 溢出用省略号显示
            white-space: nowrap;   // 规定段落中的文本不进行换行
        ```

    - 多行文本溢出:
        ```
            overflow: hidden;            // 溢出隐藏
            text-overflow: ellipsis;     // 溢出用省略号显示
            display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
            -webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
            -webkit-line-clamp:3;        // 显示的行数
        ```
#### 实现水平垂直居中的方式
    - 利用  transform实现：父元素的定位为relative,需要水平垂直居中的元素的定位设置为绝对定位，
    元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过来 transform: translate(-50%,-50%) 调整元素的中心点到页面的中心

    - 利用margin: auto实现：子元素设置为绝对定位，设置四个方向的值都为0，并将margin设置为auto，子元素有宽高的情况下，边距会在对应方向实现平分。该方法适用于盒子有宽高的情况

    - 利用设置 magin 为负值实现：利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过设置margin left/top 为元素宽高的 负50% 来调整元素的中心点到页面的中心。该方法适用于盒子宽高已知的情况

    - 使用flex布局实现：父元素的display设置为 flex; 设置justify-content:center 使得子元素在主轴方向居中，设置align-items:center 是子元素在主轴垂直方向居中
#### CSS 实现三角形
    - CSS绘制三角形主要用到的是border属性，也就是边框，平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是有三角形组成的
    - 设置一个三角形，首先需要一个宽高为0的容器，然后单独设置border的上下左右其中一边的大小，形状和颜色，另外三边边框的前两个属性和之前相同，但颜色需要设置为透明
    ```
    div {
            width: 0px;
            height: 0px;
            border-top: 100px solid #ff0;
            border-right: 100px solid transparent;
            border-left: 100px solid transparent;
            border-bottom: 100px solid transparent;
        }
    ```
#### 清除浮动的方式
    - 浮动的定义： 容器不设高度且子元素设置了 float属性时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动。
    -问题：
        浮动元素会引起父元素同级的元素，
        与浮动元素同级的非浮动元素会跟随其后
        若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构
    - 清除方法：
        给父级div定义一个具体的高度，而不是期望用子元素去撑高
        最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式
        使用BFC清除，给父级标签添加overflow:hidden或者overflow:auto，将父元素设置为BFC环境
        使用 :after 伪元素，给浮动容器设置一个内容为空的after 伪元素，after内使用 display 将 该伪原素设置为块级元素，然后使用  clear: both 

#### 隐藏元素的方法和区别
    1.opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的
    2.visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间会造成页面重绘
    3.display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间会造成页面回流+重绘
    4.position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
    5.z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。

### css 布局

#### flex布局

Flex是FlexibleBox的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。
    可以使用flex-direction来指定主轴的方向。
    可以使用justify-content来指定元素在主轴上的排列方式，
    使用align-items来指定元素在交叉轴上的排列方式。
    还可以使用flex-wrap来规定当一行排列不下时的换行方式。

对于容器中的项目：
    可以使用order属性来指定项目的排列顺序，
    还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，
    还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。

#### 两栏、三栏布局
    -  一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应，常见于普通的后台系统。
        左边的元素需要设置一个固定宽度，并且设置向左浮动， 右边元素的margin-left设置左边元素的宽度，
        自身的宽度设置为auto，用于撑满父容器剩余的宽，或者直接将右边区域使用overflow: hidden 属性，利用BFC避免左右重叠。除了浮动方式，也可以使用 flex布局，父元素的display设置为 flex,右边元素直接设置flex:1 使其占满剩余的右边空间。
    - 三栏布局:三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局.它的实现和两栏布局的方法原理上一致，也可以使用 浮动+magin方式，flex布局，绝对定位+布局来实现
### css 优化/适配/预处理

#### css 适配
    移动端适配主要有两个维度：
        适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；
        适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。

#### css 媒体查询的理解

    - 媒体查询是CSS3提出的概念，它允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。

    - 媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件的表达式，媒体类型分为移动端可pc端，表达式简单来说就是设备的物理属性的判断条件，包括像素密度，屏幕大小等，如果媒体查询中指定的媒体类型与页面所处的设备类型匹配，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会在该设备上生效

    - 通过媒体查询可以对不同设备进行样式的特殊处理，达到页面的适配效果

#### css 预处理器/后处理器

        - 预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。
        它们为css增加一些编程特性，无需考虑浏览器的兼容问题，支持在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可这些让css更加的简洁，并且增加适应性以及可读性，可维护性。预处理器中的层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。

        -  PostCSS：PostCSS 本体功能比较单一，它提供一种用 JavaScript 来处理 CSS 的方式。PostCSS 会把 CSS 解析成 AST（Abstract Syntax Tree 抽象语法树），之后由其他插件进行不同的处理，目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。它拥有插件系统完善，扩展性强，功能齐全等优点，但配置相对复杂

        - Sass 在完全兼容 CSS 语法的前提下，给 CSS 提供了变量、嵌套、混合、操作符、自定义函数等可编程能力，sass使用广泛,功能支持完善,可编程能力强;但过度使用会使得CSS 的复杂度不可控

        - Less 和 Sass 类似，完全兼容 CSS 语法，并给 CSS 提供了变量、嵌套、混合、运算等可编程能力。Less 通过 JavaScript 实现，可在浏览器端直接使用，less 使用广泛，可以在浏览器中运行，容易实现主题定制功能，但它不支持自定义函数，编程能力相对sass来说更弱

        -Stylus 基础功能和 Sass / Less 十分类似，它的特点是冒号、分号、逗号和括号都是可选项，所以可以用它写出非常简洁的 CSS


