### ts 基础

#### ts定义，特点，

    - Typescript 是一个强类型的 JavaScript 超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，而是需要编译器编译成纯Javascript来运行。

    - 它具有跨平台特性，包含ES6及以上的大部分特性，具有面向对象的特点，提供所有标准的 OOP 功能，如类、接口和模块，使用静态类型并帮助代码在编译时进行类型检查。

#### ts 优缺点
    - 优点
        增加了静态类型，可以在开发人员编写时检测错误，使得代码质量更好，更健壮。
        1. 杜绝手误导致的变量名写错;
        2. 类型可以一定程度上充当文档;
        3. IDE自动填充，自动联想;

    - 缺点：TypeScript需要很长时间来编译代码；浏览器中运行TypeScript程序时则需要执行编译步骤，效率更低。
        
#### any和 unknown
    - any 为不清楚类型的变量指定一个任意类型，这种情况下，类型检查器不会对any值进行检查,而是直接让它们通过。
    - unknown 类型表示该类型具体类型未知，和any的意义类似，但unknown会更加严格,对 unknown 类型的值执行数操作前，会对它进行某种形式的检查。

#### never和void
    - void 表示没有任何类型（可以被赋值为 null 和 undefined）。
    - never 表示一个不包含值的类型，即永远不存在的值。
    - 拥有 void 类型返回值的函数能正常运行。拥有 never 类型返回值的函数无法正常返回，无法终止，或会抛出异常。

####  tsconfig.json
    - tsconfig.json文件是一种JSON结构的文件，用于配置当前项目的编译方法，包括：
        include : 用来指定哪些文件需要被编译；
        exclude : 用来指定哪些文件不需要被编译 ：默认node_module；
        extends : 用来指定继承的配置文件；
        compilerOptions : 它是编译器的选项，是配置tsconfig中最为具体，非常重要和非常复杂的配置选项；

#### interface和type

    - 相同点：它们都是用来定义 '对象' 或者 '函数'等复杂的类型集合，并且都允许拓展(extends)。

    - type 可以声明基本类型，联合类型，元组，并支持使用 typeof 获取实例的类型来进行赋值，另一面 interface 声明可以自动合并。

    - 一般使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’。

    - interface 的两种扩展写法
        使用 extends关键字进行扩展,a extends b{}.
        通过定义同名interface进行字段扩展,a {a1: number}; a {a2: string}.

    - type的扩展:使用并且符号的一半 &,a & b{}.

#### const和readonly
    - const 用于变量，readonly 用于属性。
    - const 在运行时检查，readonly 在编译时检查。
    - 用 const 变量保存的数组，可以使用 push，pop 等方法；但是如果使用 Readonly Array 声明的数组不能使用 push，pop 等方法。

#### 常用符号
    ?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行，一般用于访问和操作对象中的某个不确定属性，避免操作空属性导致的运行错误。
    ! 非空断言运算符： 将值的值域中排除 null 和 undefined，一般用于减少ts代码waring。
    ?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。
    as 类型断言符：将值断言为 as 后面的类型，一般方便赋值和减少ts代码waring。

### ts 进阶

#### TypeScript 模块的加载机制
    - 假设有一个导入语句 import { a } from "moduleA"
        1.首先，编译器会尝试定位需要导入的模块文件，通过绝对路径或者相对路径查找文件。
        2.如果上面的解析失败了，没有查找到对应的模块，编译器会尝试定位一个外部模块声明（.d.ts）。
        3.最后，如果编译器还是不能解析这个模块，则会抛出一个错误 error TS2307: Cannot find module 'moduleA'。

####  keyof 和 typeof 关键字
    - keyof 索引类型查询操作符 获取索引类型的属性名，构成联合类型。
    - typeof 获取一个变量或对象的类型。

#### TypeScript泛型
    - 泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。可以把泛型理解为代表类型的参数。

#### typescript 的类型推断机制

    - 第一种在声明变量时赋值了，那么 typescript 会推断出该变量的类型，之后若赋值其他类型会报错。
    - 第二种声明变量时未赋值，那么 typescript 会推断该值为any，之后可以赋值为任何类型。

#### TypeScript 类型兼容性的理解

    - ts 类型兼容：当一个类型 Y 可以赋值给另一个类型 X 时， 我们就可以说类型 X 兼容类型 Y。也就是说两者在结构上是一致的，而不一定非得通过 extends 的方式继承而来
    - 接口的兼容性：X = Y 只要目标类型 X 中声明的属性变量在源类型 Y 中都存在就是兼容的（ Y 中的类型可以比 X 中的多，但是不能少。
    -  函数的兼容性：X = Y  Y 的每个参数必须能在 X 里找到对应类型的参数，参数的名字相同与否无所谓，只看它们的类型。

#### ts中的协变、逆变、双变和抗变

    - 协变；Y 类型可以赋值给 X 类型的情况就叫做协变，也可以说是 X 类型兼容 Y 类型。
    - 逆变：函数X 类型可以赋值给函数Y 类型，虽然函数Y 在调用的时候参数是按照Y类型进行约束的，但是实际上用到的是函数X的类型的规定的属性和方法，这种兼容是逆向的，既称为逆变。
    - 双变: 父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变，叫做“双向协变”。
    - 抗变（不变）：非父子类型之间不会发生型变，只要类型不一样就会报错。

#### ts工具类

    Exclude<T, U> 从 T 中排除出可分配给 U的元素。
    Omit<T, K> 的作用是忽略T中的K属性。
    Merge<A, B> 是将A，B两个对象的属性合并。
    Compute<A & B> 是将A,B的交叉类型合并。
    Intersection<T, U>的作用是取T的属性,此属性同样也存在于U。
    Overwrite<T, U> 是用U的属性覆盖T的相同属性。
