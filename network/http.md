### http

#### http 概念
    - HTTP协议，既超文本传输协议，是用于从WWW服务器传输超文本到本地浏览器的传输协议，它是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。它是一种客户端发起请求，服务器回送响应的无状态，简单快速，灵活的网络协议，在最初的版本是无链接的，请求结束后就会断开链接，同时它的报文(header部分)使用的是明文，直接将信息暴露给了外界，使得链接过程非常不安全

#### http 报文组成
    - 主体上由请求报文和响应报文组成。而其中，请求报文由请求行、请求头、空行、请求体四部分组成；响应报文由状态行、响应头、空行、响应体四部分组成
    - 请求行包含http方法，请求地址，http协议以及版本；请求头/响应头包含的就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等；空行用来区分首部与实体，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了；请求体设置的是请求的参数；状态的内容包含http协议及版本、数字状态码、状态码英文名称；响应体指定就是服务端返回的数据

#### http 请求方法

    -   HTTP1.0时代只有三种初始的请求方法，分别是 GET、POST、HEAD,get 方法一边用于简单的获取资源， post 方法一般传输资源，将客服端的信息传输给服务端之后，获得服务器资源的修改后的结果；HEAD 则用于获得报文首部

    - HTTP1.1 新增了PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT 剩下的六种方法
    PUT 用于更新服务器资源，而PATCH 则是对PUT的补充，可以对已知资源进行部分更新；
    DELETE 方法用于删除服务器上指定的资源；OPTIONS则是列出请求资源支持的请求方法，一般用来请求跨域请求的设置；TRACE可以追踪请求/响应路径，用于测试或诊断；最后CONNECT方法会将当前连接改为管道方式，可以用于代理服务器

    - Get 和 Post的区别
        1. Post 方法更加安全：首先GET参数通过URL传递，一些敏感信息容易被获取和篡改，而POST的参数是放在Request body中；GET的请求记录被浏览器主动缓存，请求参数会保留在浏览器历史记录中，而POST不会；
        2.Post 方法功能更强大：GET请求在URL中传递的参数会根据浏览器限制进行长度限制，而POST没有限制；GET请求只能进行URL编码，而POST支持多种编码方式
        3.请求过程不同：发送GET请求时，浏览器会把 http header和data一起发出去，只产生一个数据包，使用POST会先发送header，服务器响应100 continue后，浏览器再发送data，会产生两个数据包。

#### 常见状态码

        - 分类：
            1xx: 指示信息——表示请求已接收，继续处理
            2xx: 成功——表示请求已被成功接收
            3xx: 重定向——表示要完成请求必须进行进一步操作
            4xx: 客户端错误——表示请求有语法错误或请求无法实现
            5xx: 服务端错误——表示服务器未能实现合法的请求

        - 常见码的具体含义
            301永久重定向
            302临时重定向
            304请求资源未修改，可以使用缓存的资源，不用在服务器取
            400请求有语法错误
            401没有权限访问
            403服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时
            500服务器内部错误，无法完成请求
            503请求未完成，因服务器过载、宕机或维护等

#### 持久连接/长连接
     - http1.0协议采用的是"请求-应答"模式，该模式下模式的每个请求/应答客户与服务器都要新建一个连接，完成之后立即断开连接，后续的http1.1版本在请求头添加Connection: Keep-Alive，使用Keep-Alive模式进行长链接，它在建立一个TCP连接后使客户端到服务端的连接持续有效，可以发送/接受多个http请求/响应，当出现对服务器的后续请求时，该功能避免了建立或者重新建立连接

     - 优缺点
        1. 优点:不需要经常建立和关闭连接会减少CPU及内存的使用，同时减少了网络堵塞和后续请求的响应时间，可以支持管道化的请求及响应模式
        2. 缺点：一个长连接建立后，没有及时关闭会造成服务器的资源浪费，管道化模式下同一个TCP连接里发一个请求后不必等待服务器应答就可以发送新的请求出去，如果有许多请求，并且前面的请求响应很慢，那么前面的请求会阻塞后续请求的响应处理，造成了队头阻塞。

#### 队头阻塞的解决方法
    - 并发链接：浏览器支持一个域名分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务，现在的浏览器标准中一个域名并发连接可以有6~8个
    - 多路复用：HTTP2.0支持多路复用模式，在一个TCP连接中发送多个请求，在一个链接中将资源地址的多个次级的域名，可以让不同的资源从不同的域名中获取，而它们都指向同一台服务器，这样使得同域名下所有通信都是在单链接中完成，提高了连接的复用率

#### http 代理
    - 代理方式
        1.普通代理(中间人代理)：代理服务器相当于一个中间人，一直帮客服端和服务器传递东西，对于客户端来说，它扮演的是服务器角色，接受请求后返回响应，同时对于服务器来说，它就是客服端。这种模式在中间层帮助我们进行过滤、缓存、负载均衡(多台服务器共用一台代理情况下)等一些处理。

        2.隧道代理：客户端通过CONNECT方法请求隧道代理创建一个可以到任意目标服务器和端口号的TCP连接，创建成功之后隧道代理只做请求和响应数据的转发，中间它不会做任何处理，这种方式中我们可以使用中间代理和服务端进行TLS握手，然后进行加密传输

    - 好处
        1.突破访问限制：如访问一些单位或集团内部资源，或用国外代理服务器(翻墙)，访问国外网站等。
        2.提高安全性：上网者可以通过这种方式隐藏自己的IP，免受攻击。还可以对数据过滤，对非法IP限流等。
        3.负载均衡：客户端请求先到代理服务器，而代理服务器可以有众多的源服务器，代理服务器收到请求后，通过特定的算法把请求分发给不同的源服务器，让各个源服务器负载尽量均衡，这样可以处理更多的请求，减少请求过多引起的服务器崩溃。
        4.缓存代理：将内容缓存到代理服务器
    
    - 代理模式：
        1.正向代理：工作在客户端的代理为正向代理。使用正向代理的时候，需要在客户端配置需要使用的代理服务器，正向代理对服务端透明。比如抓包工具Fiddler、Charles以及访问一些外网网站的代理工具都是正向代理。

        2. 工作在服务端的代理称为反向代理。使用反向代理的时候，不需要在客户端进行设置，反向代理对客户端透明。如Nginx就是反向代理

#### http版本变迁

    - 最早版本 0.9：请求方法只有一个GET，传输的内容只支持纯文本内容

    - HTTP 1.0(1996年)：支持任意数据类型，增加了POST、HEAD方法，但仍然是无法复用TCP连接，不支持长连接，增加了更多请求响应头信息，使用Last-Modified/If-Modified-Since和Expires进行缓存判断

    - HTTP 1.1（1997年）:引入更多的请求方法类型PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT;通过设置请求头connection字段为keep-alive来保持TCP连接不关闭，进行长连接；引入管道连接机制，可以在同一TCP连接里，同时发送多个请求；增加了用于强化缓存管理和控制的Cache-Control、ETag/If-None-Match字段，增加分块响应，断点续传模式用于大文件上传

    - HTTP 2.0(2015年):使用新的二进制协议，不再是纯文本，这样可以避免文本歧义，缩小请求体积；支持多路复用，使得同域名下所有通信都是在单链接完成，提高了连接的复用率，减少了请求拥塞；允许服务端主动推送数据给客户端，同时TLS 进行会话加密，增加了安全性

    - HTTP 3.0(2018)：在传输层直接干掉TCP，用UDP替代；实现了一套新的拥塞控制算法，彻底解决TCP中队头阻塞的问题，实现了类似TCP的流量控制、传输可靠性的功能；由于是基于UDP的，实现了类似的快速握手功能

####  缓存

    - DNS 缓存

    - http 缓存
        1. 过程：用户请求资源是首先判断该资源是否浏览器中是否存在该资源的缓存，如果不存则会向服务器发送请求，获取到结果后将资源存入浏览器缓存中；如果存在缓存则需要判断该缓存资源是否过期，这里会有三种处理方法：

        2.三种模式：
            第一种是强缓存模式：第一次请求时，服务器把资源的过期时间通过响应头中的Expires和Cache-Control两个字段告诉浏览器，之后再请求这个资源的话，会判断有没有过期，没有过期就直接拿来用，不向服务器发起请求，这就是强缓存，Expires是 Cache-Control的低价级版，用于兼容部分Cache-Control不生效的浏览器，当它们同时存在时， Cache-Control 优先级高于 Expires

            第二种是协商缓存模式：第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，还会在响应头添加 Last-Modified 字段，告诉浏览器该资源的最后修改时间，然后浏览器再次请求的时候就把这个时间再通过另一个字段If-Modified-Since，发送给服务器，服务器再把这两个字段的时间对比，如果是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用即可；如果对比不一样说明资源有更新，就返回状态码200和新的资源。
        
            但时间对比存在几个缺点：
                1.如果本地打开了缓存文件，即使没有对文件进行修改，但还是会造成Last-Modified被修改，服务器端不能命中缓存导致发送相同资源
                2.因为Last-Modified只能以秒计时，如果在不可感知的时间内修改了文件，服务器端会认为还是命中了，无法返回正确的资源
                3.如果资源有周期性变化，如资源修改后，在一个周期内又改回了原来的样子，我们认为这个周期前的缓存是可以使用的，但是Last-Modified

            ETag和If-None-Match：Etag字段表示当前资源文件的一个唯一标识。这个标识符由服务器基于文件内容编码生成，能精准感知文件的变化，只要文件内容不同，ETag就会重新生成，浏览器再次请求时就把这个文件标识 再通过另一个字段 If-None-Match，发送给服务器，服务器再把这两个字段的值对比，如果发现是一样的，则返回304和空响应体,否则返回200和新资源

            第三种是启发式缓存：响应中没有Expires，Cache-Control：max-age或Cache-Control:s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算缓存有效期，通常会根据响应头中的Date字段(报文创建时间)减去Last-Modified值的10%作为缓存时间

    - CDN缓存
        CDN就是内容分发网络，是构建在现有网络基础之上的智能虚拟网络,依靠部署在各个地方的边缘服务器，通过分布式存储、负载均衡、网络请求的重定向和内容管理等功能模块能高效地为用户请求提供所需要的资源。
        当我们发送一个请求时，浏览器本地缓存失效的情况下，CDN会帮我们去计算哪得到这些内容的路径短而且快，然后向最近的CDN节点请求数据，然后向最近的CDN节点请求数据。

### https

#### https 概念
    - HTTPS 是超文本传输安全协议，它在HTTP的TCP和HTTP中建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。

#### https原理
    1.客户端请求服务器，并告诉服务器自身支持的加密算法以及密钥长度等信息
    2.服务器响应公钥和服务器证书
    3.客户端验证证书是否合法，然后生成一个会话密钥，并用服务器的公钥加密密钥，把加密的结果通过请求发送给服务器
    4.服务器使用私钥解密被加密的会话密钥并保存起来，然后使用会话密钥加密消息响应给客户端，表示自己已经准备就绪
    5.客户端使用会话密钥解密消息，知道了服务器已经准备就绪。
    6.后续客户端和服务器使用会话密钥加密信息传递消息

#### https 中 TLS 的加密算法

    - TLS 实际用的是对称加密和非对称加密的混合加密算法。通过 非对称加密算法 交换 对称加密算法 的密钥，交换完成后，再使用对称加密进行加解密传输数据。这样就保证了会话的机密性
    
    - 密钥:它是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。
    - ：它又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密
    - 非对称加密： 它也叫做公钥加密，它使用一对密钥，即公钥和私钥，私钥被自己保存，不对外泄露，
    公钥是公共的密钥，任何人都可以获得该密钥，二者成对出现，用其中一个进行加密，另一个用来进行解密

#### https优缺点
    - 优点：
        使得内容加密，中间无法查看原始内容
        可以进行身份认证，保证用户访问正确。如访问百度，即使DNS被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持
        保证数据完整性，防止内容被第三方冒充或篡改
    - 缺点
        需要费用，功能越强大的证书费用越贵
        https双方加解密，耗费更多服务器资源
        https握手更耗时，降低一定用户访问速度


### 其他

#### 网络攻击
    XSS：XSS 是指跨站脚本攻击。攻击者利用站点的漏洞，在表单提交时，在表单内容中加入一些恶意脚本，当其他正常用户浏览页面，而页面中刚好出现攻击者的恶意脚本时，脚本被执行，从而使得页面遭到破坏，或者用户信息被窃取。
    要防范 XSS 攻击，需要在服务器端过滤脚本代码，将一些危险的元素和属性去掉或对元素进行HTML实体编码。

    CSRF：CSRF 是跨站请求伪造，是一种挟制用户在当前已登录的Web应用上执行非本意的操作的攻击方法
    它首先引导用户访问一个危险网站，当用户访问网站后，网站会发送请求到被攻击的站点，这次请求会携带用户的cookie发送，因此就利用了用户的身份信息完成攻击。防御 CSRF 攻击有多种手段，包括不使用cookie，为表单添加校验的 token 校验，在cookie中使用sameSite字段，服务器检查 referer 字段
#### 网络存储

    - cookie：它出现的时间早，兼容性较好，所有浏览器均支持。浏览器针对 cookie 会有一些默认行为，比如当响应头中出现set-cookie字段时，浏览器会自动保存 cookie 的值；再比如，浏览器发送请求时，会附带匹配的 cookie 到请求头中。这些默认行为，使得 cookie 长期以来担任着维持登录状态的责任，与此同时，也正是因为浏览器的默认行为，给了恶意攻击者可乘之机，导致它不够安全，同时cookie 的大小是有限制的，一般浏览器会限制同一个域下的 cookie 总量为 4M

    - sessionStorage 和 localStorage：它们是html5新增的本地存储方案，前者用于保存会话级别的数据，后者用于更持久的保存数据。浏览器针对它们没有任何默认行为，这样一来，就把保存数据、读取数据的工作交给了前端开发者，这就让恶意攻击者难以针对登录状态进行攻击，会更加安全，同时它们也没有大小限制

#### 跨域解决方案

    - 跨域概念

    - JSONP

    - cors

    - window.postmessage

    - 网络代理
